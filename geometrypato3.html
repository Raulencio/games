<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Geometry Duck III</title>

    <link rel="icon" href="pato.png" type="image/png">

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #111;
        }

        canvas {
            display: block;
            background: linear-gradient(#005163, #026159);
        }

        #botonera {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: space-around;
            padding: 1px 0;
            z-index: 10;
        }

        #botonera button {
            background: #04a;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #botonera button:hover {
            background: #07c;
        }
    </style>
</head>

<body>
    <canvas id="game"></canvas>

    <div id="botonera">
        <button id="btn1" onclick="togglePause()">Pausa </button>
        <button id="btn2" onclick="gravedad()">Gravedad</button>
        <button id="btn3" onclick="velocidad()">Velocidad</button>
        <button id="btn4" onclick="invencibilidad()">Invencibilidad</button>
        <button id="btn5">♦</button>
        <button id="btn6">♣</button>
        <button id="btn7">♠</button>
        <button id="btn8">•</button>
        <button id="btn9">◘</button>
        <button id="btn10" onclick="abrirtienda()">Tienda</button>
    </div>

    <script src="js/skrips.js"></script>
    <script>

        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");


        let timeOfDay = 0;

        let player = { x: 0, y: 0, width: 0, height: 0, dy: 0, jumps: 0, maxJumps: 2 };
        let gravity = 0;
        let jumpStrength = 0;

        let tripleJumpActive = false;
        let tripleJumpTimer = 0;
        let tripleJumpOrbs = [];

        let obstacles = [];
        let orbs = [];
        let particles = [];
        let speedOrbs = [];

        let monedas = 0;
        let coins = []; // lista de monedas

        let vidas = 0;
        let heartOrbs = [];


        let invincible = false;
        let invincibleTimer = 0;
        let shieldOrbs = [];




        let frame = 0;

        let gameOver = true;
        let inverted = false;

        let score = 0;
        let saltos = 0;
        let gameSpeed = 5;

        let groundY = 0;
        const ceilingY = 0;


        let paused = false;

        function togglePause() {
            paused = !paused;
        }

        function gravedad() {
            inverted = !inverted;

        }
        function velocidad() {
            gameSpeed += 1;
        }

        function invencibilidad() {
            invincible = !invincible;
            if (invincible) {
                invincibleTimer = 30000;
            } else {
                invincibleTimer = 0;
            }

        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            groundY = canvas.height * 0.8;

            player.width = canvas.width * 0.025;
            player.height = canvas.height * 0.05;
            player.x = canvas.width * 0.0625;
            player.y = groundY - player.height;

            gravity = canvas.height * 0.002;
            jumpStrength = -canvas.height * 0.03;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        document.addEventListener("keydown", e => {
            if (gameOver && e.code === "Space") {
                resetGame();
                return;
            }
            if (e.code === "Space" && player.jumps < player.maxJumps) {
                player.dy = inverted ? -jumpStrength : jumpStrength;
                player.jumps++; saltos++;
            }
        });

        canvas.addEventListener("mousedown", () => {
            if (gameOver) {
                resetGame();
                return;
            }
            if (player.jumps < player.maxJumps) {
                player.dy = inverted ? -jumpStrength : jumpStrength;
                player.jumps++; saltos++;
            }
        });

        canvas.addEventListener("touchstart", e => {
            e.preventDefault();
            if (gameOver) {
                resetGame();
                return;
            }
            if (player.jumps < player.maxJumps) {
                player.dy = inverted ? -jumpStrength : jumpStrength;
                player.jumps++; saltos++;
            }
        }, { passive: false });


        function drawTriangle(x, y, width, height) {
            ctx.beginPath();
            ctx.moveTo(x, y + height);
            ctx.lineTo(x + width / 2, y);
            ctx.lineTo(x + width, y + height);
            ctx.closePath();
            ctx.fill();
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 24; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: Math.random() * 4 - 2,
                    dy: Math.random() * 4 - 2,
                    life: 30,
                    color: color
                });
            }
        }

        let bestScore = localStorage.getItem("bestScore") || 0;

        let bestCoins = localStorage.getItem("bestCoins") || 0;

        let bestSaltos = localStorage.getItem("bestSaltos") || 0;

        let dinero = parseInt(localStorage.getItem("dinero")) || 0;



        let rainDrops = [];

        function createRain() {
            // Crear gotas de lluvia al azar a lo ancho del canvas
            for (let i = 0; i < 15; i++) {
                rainDrops.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * -canvas.height, // empezar arriba fuera de pantalla
                    length: 10 + Math.random() * 10,
                    speed: 4 + Math.random() * 4
                });
            }
        }

        function updateRain() {
            ctx.strokeStyle = "rgba(174,194,224,0.5)";
            ctx.lineWidth = 1;
            ctx.lineCap = "round";

            for (let i = 0; i < rainDrops.length; i++) {
                let drop = rainDrops[i];
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x, drop.y + drop.length);
                ctx.stroke();

                drop.y += drop.speed;

                if (drop.y > groundY) {
                    drop.y = Math.random() * -canvas.height; // reaparece arriba
                    drop.x = Math.random() * canvas.width;
                }
            }
        }


        let botonesTienda = [];

        function comprarVida() {
            if (dinero >= 1) {
                dinero -= 1;
                vidas++;
                localStorage.setItem("dinero", dinero);
            }
        }

        function comprarInvencibilidad() {
            if (dinero >= 3) {
                dinero -= 3;
                invincible = true;
                invincibleTimer = 600;
                localStorage.setItem("dinero", dinero);
            }
        }

        function comprarTripleSalto() {
            if (dinero >= 2) {
                dinero -= 2;
                tripleJumpActive = true;
                tripleJumpTimer = 800;
                player.maxJumps = 3;
                localStorage.setItem("dinero", dinero);
            }
        }



        let tiendaAbierta = false;
        function abrirtienda() {

            if (!gameOver) {
                tiendaAbierta = !tiendaAbierta;
            }

        }


        document.addEventListener("keydown", (e) => {
            if (e.code === "KeyT" && !gameOver) {
                tiendaAbierta = !tiendaAbierta;
            }
        });






        function dibujarTienda() {
            // Fondo semitransparente para destacar la tienda
            ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "white";
            ctx.font = "30px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("TIENDA", canvas.width / 2, 50);

            // Mostrar monedas actuales
            ctx.fillText("Monedas: " + dinero, canvas.width / 2, 100);

            // Opciones de compra como botones
            const botones = [
                { texto: "+1 Vida Extra (1 monedas)", x: canvas.width / 2 - 150, y: 150, w: 300, h: 40, precio: 1, accion: comprarVida },
                { texto: "Invencibilidad (3 monedas)", x: canvas.width / 2 - 150, y: 200, w: 300, h: 40, precio: 3, accion: comprarInvencibilidad },
                { texto: "Triple Salto (2 monedas)", x: canvas.width / 2 - 150, y: 250, w: 300, h: 40, precio: 2, accion: comprarTripleSalto },
            ];

            ctx.font = "20px sans-serif";
            ctx.textAlign = "center";

            botones.forEach(b => {
                // Botón fondo
                ctx.fillStyle = dinero >= b.precio ? "green" : "gray";
                ctx.fillRect(b.x, b.y, b.w, b.h);

                // Texto del botón
                ctx.fillStyle = "white";
                ctx.fillText(b.texto, b.x + b.w / 2, b.y + b.h / 2 + 7);
            });

            // Guardar botones en global para detectar clicks
            botonesTienda = botones;
        }


        canvas.addEventListener("click", e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            console.log("Click en", x, y);

            if (botonesTienda) {
                console.log(botonesTienda);
                botonesTienda.forEach(b => {
                    console.log("Botón:", b);
                    if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
                        console.log("Click en botón:", b.texto);
                        b.accion();
                    }
                });
            }
        });




        canvas.addEventListener("touchstart", e => {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            if (botonesTienda) {
                botonesTienda.forEach(b => {
                    if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
                        b.accion();
                        dibujarTienda(); // refresca la tienda tras la compra
                    }
                });
            }
            e.preventDefault(); // para que no haga scroll o zoom
        });



        let floatingTexts = [];

        function addFloatingText(text, x, y, color = "white", duration = 60) {
            // Ajustamos x y y para que el texto aparezca a la izquierda y un poco más abajo
            const adjustedX = x - 25; // 20 píxeles a la izquierda
            const adjustedY = y + 10; // 10 píxeles más abajo

            floatingTexts.push({ text, x: adjustedX, y: adjustedY, alpha: 1, duration, color });
        }


        function updateFloatingTexts() {
            for (let i = 0; i < floatingTexts.length; i++) {
                let ft = floatingTexts[i];
                ft.y -= 1; // asciende suavemente
                if (ft.y < 20) ft.y = 20; // evita que suba demasiado

                ft.alpha -= 1 / ft.duration; // desvanece
                ft.duration--;

                ctx.fillStyle = ft.color.includes("#")
                    ? hexToRgba(ft.color, ft.alpha)
                    : nameToRgba(ft.color, ft.alpha);

                ctx.font = "20px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText(ft.text, ft.x, ft.y);

                if (ft.duration <= 0) {
                    floatingTexts.splice(i, 1);
                    i--;
                }
            }
        }

        function hexToRgba(hex, alpha) {
            let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                return r + r + g + g + b + b;
            });

            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ?
                `rgba(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}, ${alpha.toFixed(2)})` :
                `rgba(255,255,255,${alpha.toFixed(2)})`;
        }

        function nameToRgba(name, alpha) {
            // Crea un elemento temporal para obtener el color computado
            let temp = document.createElement("div");
            temp.style.color = name;
            document.body.appendChild(temp);

            let rgb = getComputedStyle(temp).color;
            document.body.removeChild(temp);

            // rgb puede ser "rgb(r, g, b)" o "rgba(r, g, b, a)"
            let rgbValues = rgb.match(/\d+/g);
            return rgbValues ?
                `rgba(${rgbValues[0]}, ${rgbValues[1]}, ${rgbValues[2]}, ${alpha.toFixed(2)})` :
                `rgba(255,255,255,${alpha.toFixed(2)})`;
        }


        // Función para calcular la opacidad parpadeante según el tiempo restante
        function getBlinkAlpha(timer, threshold = 180, blinkSpeed = 10) {
            if (timer > threshold) return 1; // opacidad total si queda mucho tiempo
            // parpadeo entre 0.2 y 1 con ciclo de blinkSpeed frames
            return 0.6 + 0.4 * Math.abs(Math.sin(timer / blinkSpeed));
        }



        function resetGame() {
            player.y = groundY - player.height;
            player.dy = 0;
            player.jumps = 0;
            inverted = false;
            tripleJumpActive = false;
            tripleJumpTimer = 0;

            obstacles = [];
            coins = [];
            orbs = [];
            speedOrbs = [];
            tripleJumpOrbs = [];
            heartOrbs = [];
            shieldOrbs = [];
            particles = [];
            floatingTexts = [];

            gameSpeed = 5;
            score = 0;
            saltos = 0;
            monedas = 0;
            vidas = 0;

            frame = 0;
            gameOver = false;
        }



        const patoImg = new Image();
        patoImg.src = "pato.png";





        function update() {

            ctx.clearRect(0, 0, canvas.width, canvas.height);


            // Avanza lentamente el tiempo para el ciclo día-noche
            timeOfDay += 0.0001;
            if (timeOfDay > 1) timeOfDay = 0; // ciclo infinito

            function lerpColor(a, b, t) {
                const lerp = (v0, v1, t) => v0 + (v1 - v0) * t;
                return {
                    r: lerp(a.r, b.r, t),
                    g: lerp(a.g, b.g, t),
                    b: lerp(a.b, b.b, t)
                };
            }

            function rgbToString(c) {
                return `rgb(${Math.round(c.r)},${Math.round(c.g)},${Math.round(c.b)})`;
            }

            const colors = [
                { top: { r: 255, g: 153, b: 51 }, bottom: { r: 102, g: 204, b: 255 } },  // Amanecer
                { top: { r: 51, g: 153, b: 255 }, bottom: { r: 0, g: 102, b: 204 } },    // Día
                { top: { r: 255, g: 102, b: 102 }, bottom: { r: 51, g: 51, b: 102 } },   // Atardecer
                { top: { r: 10, g: 10, b: 40 }, bottom: { r: 0, g: 0, b: 20 } }          // Noche
            ];

            const phase = timeOfDay * colors.length;
            const index = Math.floor(phase) % colors.length;
            const nextIndex = (index + 1) % colors.length;
            const t = phase - Math.floor(phase);

            const topColor = lerpColor(colors[index].top, colors[nextIndex].top, t);
            const bottomColor = lerpColor(colors[index].bottom, colors[nextIndex].bottom, t);

            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, rgbToString(topColor));
            gradient.addColorStop(1, rgbToString(bottomColor));

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);



            if (gameOver) {
                ctx.textAlign = "center";
                ctx.fillStyle = "red";
                ctx.font = canvas.height * 0.08 + "px sans-serif";
                ctx.fillText("Geometry Duck III", canvas.width / 2, canvas.height / 2 - canvas.height * 0.1);
                ctx.font = canvas.height * 0.04 + "px sans-serif";
                ctx.fillText("Presiona para Iniciar", canvas.width / 2, canvas.height / 2 + canvas.height * 0.05);
                ctx.fillStyle = "white";
                ctx.fillText("Puntaje máximo: " + bestScore, canvas.width / 2, canvas.height / 2 + canvas.height * 0.20);
                ctx.fillText("Monedas máximas: " + bestCoins, canvas.width / 2, canvas.height / 2 + canvas.height * 0.25);
                ctx.fillText("Maximo de Saltos: " + bestSaltos, canvas.width / 2, canvas.height / 2 + canvas.height * 0.30);

                requestAnimationFrame(update);
                return; // importante para no continuar procesando el juego
            }

            if (tiendaAbierta) {
                // Pintar la tienda y no actualizar el juego mientras la tienda está abierta
                dibujarTienda();
                requestAnimationFrame(update);
                return;
            }

            if (paused) {
                // Mostrar texto de "Pausado" en el centro
                ctx.textAlign = "center";
                ctx.fillStyle = "yellow";
                ctx.font = canvas.height * 0.06 + "px sans-serif";
                ctx.fillText("PAUSA", canvas.width / 2, canvas.height / 2);

                requestAnimationFrame(update);
                return;
            }

            ctx.strokeStyle = "#888";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, ceilingY);
            ctx.lineTo(canvas.width, ceilingY);
            ctx.stroke();

            for (let i = 0; i < particles.length; i++) {
                let p = particles[i];
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 2, 2);



                p.x += p.dx;
                p.y += p.dy;
                p.life--;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                    i--;
                }
            }

            player.dy += inverted ? -gravity : gravity;
            player.y += player.dy;

            if (!inverted && player.y + player.height > groundY) {
                player.y = groundY - player.height;
                player.dy = 0;
                player.jumps = 0;
            } else if (inverted && player.y < ceilingY) {
                player.y = ceilingY;
                player.dy = 0;
                player.jumps = 0;
            }

            updateRain();



            if (invincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) {
                    invincible = false;
                }
            }




            ctx.save();

            ctx.shadowColor = invincible ? "gold" : (tripleJumpActive ? "blue" : "green");
            ctx.shadowBlur = 8; // intensidad de la sombra
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;

            if (inverted) {
                ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
                ctx.scale(1, -1);
                ctx.drawImage(patoImg, -player.width / 2, -player.height / 2, player.width, player.height);
            } else {
                ctx.drawImage(patoImg, player.x, player.y, player.width, player.height);
            }

            ctx.restore();

            if (tripleJumpActive) {
                tripleJumpTimer--;
                if (tripleJumpTimer <= 0) {
                    tripleJumpActive = false;
                    player.maxJumps = 2;
                }
            }


            if (frame % 1000 === 0) {
                let heartY = (canvas.height / 2) - 40;
                heartOrbs.push({ x: canvas.width + 1200, y: heartY, radius: 15 });
            }

            if (frame % 1200 === 0) {
                let shieldY = (canvas.height / 2) - 40;
                shieldOrbs.push({ x: canvas.width + 800, y: shieldY, radius: 15 });
            }



            if (frame % 60 === 0) {
                let cantidad = Math.floor(Math.random() * 7);
                for (let c = 0; c < cantidad; c++) {
                    let distancia = c * canvas.width * 0.075;
                    let type = Math.floor(Math.random() * 8);
                    let width = canvas.width * 0.025;
                    let height = canvas.height * 0.1;

                    if (type === 0) {
                        obstacles.push({ x: canvas.width + distancia, y: groundY - height, width, height, type: "spike" });
                    } else if (type === 1) {
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width, height, type: "spikeTop" });
                    } else if (type === 2 || type === 3) {
                        let blockHeight = type === 2 ? canvas.height * 0.05 : canvas.height * 0.15;
                        obstacles.push({ x: canvas.width + distancia, y: groundY - blockHeight, width: width * 1.5, height: blockHeight, type: "block" });
                    } else if (type === 4) {
                        obstacles.push({ x: canvas.width + distancia, y: groundY - canvas.height * 0.025, width: width * 2, height: canvas.height * 0.025, type: "jumpPad" });
                    } else if (type === 5) {
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width: width * 2, height: canvas.height * 0.025, type: "jumpPadTop" });
                    } else if (type === 6 || type === 7) {
                        let blockHeight = canvas.height * (0.05 + Math.random() * 0.05);
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width: width * 1.5, height: blockHeight, type: "blockTop" });
                    }
                }
            }



            if (frame % 250 === 0) { // una moneda
                let coinY = Math.random() * (groundY - canvas.height * 0.1) + canvas.height * 0.05; // posición Y aleatoria entre algo arriba del suelo y un poco arriba
                coins.push({ x: canvas.width + 600, y: coinY, radius: 15 });
            }


            if (frame % 200 === 0) { //orbe de gravedad
                let orbY = (canvas.height / 2) - 40;
                orbs.push({ x: canvas.width, y: orbY, radius: 10 });
            }
            if (frame % 500 === 0) { //orbe de velocidad
                let orbY = (canvas.height / 2) - 40;
                speedOrbs.push({ x: canvas.width + 200, y: orbY, radius: 10 });
            }
            if (frame % 800 === 0) { //power up triple salto
                let orbY = (canvas.height / 2) - 40;
                tripleJumpOrbs.push({ x: canvas.width + 400, y: orbY, radius: 10 });
            }




            ctx.fillStyle = "gold";
            for (let i = 0; i < shieldOrbs.length; i++) {
                let orb = shieldOrbs[i];
                orb.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                if (player.x < orb.x + orb.radius &&
                    player.x + player.width > orb.x - orb.radius &&
                    player.y < orb.y + orb.radius &&
                    player.y + player.height > orb.y - orb.radius) {

                    invincible = true;
                    invincibleTimer = 600; // dura 10 segundos si el juego corre a 60 fps
                    shieldOrbs.splice(i, 1);
                    i--;
                    score += gameSpeed;
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "gold");
                    addFloatingText("+" + gameSpeed, player.x + player.width / 2, player.y, "gold");
                }
            }



            ctx.fillStyle = "red";
            for (let i = 0; i < heartOrbs.length; i++) {
                let orb = heartOrbs[i];
                orb.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                if (player.x < orb.x + orb.radius &&
                    player.x + player.width > orb.x - orb.radius &&
                    player.y < orb.y + orb.radius &&
                    player.y + player.height > orb.y - orb.radius) {

                    vidas++;
                    heartOrbs.splice(i, 1);
                    i--;
                    score += 50;
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "red");
                    addFloatingText("+50", player.x + player.width / 2, player.y, "red");
                }
            }


            ctx.fillStyle = "yellow";
            for (let i = 0; i < coins.length; i++) {
                let coin = coins[i];
                coin.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(coin.x, coin.y, coin.radius, 0, Math.PI * 2);
                ctx.fill();

                if (
                    player.x < coin.x + coin.radius &&
                    player.x + player.width > coin.x - coin.radius &&
                    player.y < coin.y + coin.radius &&
                    player.y + player.height > coin.y - coin.radius
                ) {
                    monedas++;
                    dinero++;
                    localStorage.setItem("dinero", dinero);
                    coins.splice(i, 1);
                    i--;
                    score += 100;
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "yellow");
                    addFloatingText("+100", player.x + player.width / 2, player.y, "yellow");
                }
            }


            ctx.fillStyle = "blue";
            for (let i = 0; i < tripleJumpOrbs.length; i++) {
                let orb = tripleJumpOrbs[i];
                orb.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                if (player.x < orb.x + orb.radius && player.x + player.width > orb.x - orb.radius && player.y < orb.y + orb.radius && player.y + player.height > orb.y - orb.radius) {
                    tripleJumpActive = true;
                    tripleJumpTimer = 800;
                    player.maxJumps = 3;
                    tripleJumpOrbs.splice(i, 1);
                    i--;
                    score += gameSpeed * 3;
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "blue");
                    addFloatingText("+" + gameSpeed * 3, player.x + player.width / 2, player.y, "blue");
                }
            }

            ctx.fillStyle = "cyan";
            for (let i = 0; i < orbs.length; i++) {
                let orb = orbs[i];
                orb.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                if (player.x < orb.x + orb.radius && player.x + player.width > orb.x - orb.radius && player.y < orb.y + orb.radius && player.y + player.height > orb.y - orb.radius) {
                    inverted = !inverted;
                    orbs.splice(i, 1);
                    i--;
                    player.dy = 0;
                    player.jumps = 0;
                    score += 10;
                    createParticles(player.x + player.width, player.y + player.height, "cyan");
                    addFloatingText("+10", player.x + player.width / 2, player.y, "cyan");


                }
            }

            ctx.fillStyle = "magenta";
            for (let i = 0; i < speedOrbs.length; i++) {
                let orb = speedOrbs[i];
                orb.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                if (player.x < orb.x + orb.radius && player.x + player.width > orb.x - orb.radius && player.y < orb.y + orb.radius && player.y + player.height > orb.y - orb.radius) {
                    gameSpeed += 1;
                    speedOrbs.splice(i, 1);
                    i--;

                    score += 10 * gameSpeed;

                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "magenta");
                    addFloatingText("+" + 10 * gameSpeed, player.x + player.width / 2, player.y, "magenta");
                }
            }
            for (let i = 0; i < obstacles.length; i++) {
                let obs = obstacles[i];
                obs.x -= gameSpeed;

                if (obs.type === "spike" || obs.type === "spikeTop") {
                    ctx.fillStyle = "lime";

                    if (obs.type === "spike") {
                        ctx.beginPath();
                        ctx.moveTo(obs.x, obs.y + obs.height);
                        ctx.lineTo(obs.x + obs.width / 2, obs.y);
                        ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.moveTo(obs.x, obs.y);
                        ctx.lineTo(obs.x + obs.width / 2, obs.y + obs.height);
                        ctx.lineTo(obs.x + obs.width, obs.y);
                        ctx.closePath();
                        ctx.fill();
                    }

                    if (player.x < obs.x + obs.width &&
                        player.x + player.width > obs.x &&
                        player.y < obs.y + obs.height &&
                        player.y + player.height > obs.y) {

                        if (invincible) {
                            // ✨ Destruye pincho con partículas esmeralda
                            createParticles(obs.x + obs.width / 2, obs.y + obs.height / 2, "lime");
                            obstacles.splice(i, 1);
                            i--;
                            score += 50;
                            addFloatingText("+50", player.x + player.width / 2, player.y, "lime");
                        } else {
                            if (vidas > 0) {
                                vidas--;
                                invincible = true;
                                invincibleTimer = 60;
                            } else {
                                gameOver = true;
                            }
                        }
                    }

                } else if (obs.type === "block") {
                    ctx.fillStyle = "orange";
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                    if (player.x + player.width > obs.x && player.x < obs.x + obs.width) {
                        // 🛡️ Destruye solo si en gravedad normal y tocando
                        if (invincible &&
                            !inverted &&
                            player.y + player.height > obs.y &&
                            player.y < obs.y + obs.height) {
                            createParticles(obs.x + obs.width / 2, obs.y + obs.height / 2, "orange");
                            obstacles.splice(i, 1);
                            i--;
                            score += 50;
                            addFloatingText("+50", player.x + player.width / 2, player.y, "orange");
                        } else {
                            if (!inverted) {
                                if (player.y + player.height > obs.y && player.y + player.height <= obs.y + player.dy + gravity) {
                                    player.y = obs.y - player.height;
                                    player.dy = 0;
                                    player.jumps = 0;
                                } else if (player.y + player.height > obs.y) {
                                    if (vidas > 0) {
                                        vidas--;
                                        invincible = true;
                                        invincibleTimer = 60;
                                    } else {
                                        gameOver = true;
                                    }
                                }
                            } else {
                                if (player.y < obs.y + obs.height && player.y >= obs.y + obs.height + player.dy - gravity) {
                                    player.y = obs.y + obs.height;
                                    player.dy = 0;
                                    player.jumps = 0;
                                } else if (player.y < obs.y + obs.height && player.y + player.height > obs.y + obs.height) {
                                    if (vidas > 0) {
                                        vidas--;
                                        invincible = true;
                                        invincibleTimer = 60;
                                    } else {
                                        gameOver = true;
                                    }
                                }
                            }
                        }
                    }
                } else if (obs.type === "blockTop") {
                    ctx.fillStyle = "orange";
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                    if (player.x + player.width > obs.x && player.x < obs.x + obs.width) {
                        // 🛡️ Destruye solo si en gravedad invertida y tocando
                        if (invincible &&
                            inverted &&
                            player.y + player.height > obs.y &&
                            player.y < obs.y + obs.height) {
                            createParticles(obs.x + obs.width / 2, obs.y + obs.height / 2, "orange");
                            obstacles.splice(i, 1);
                            i--;
                            score += 50;
                            addFloatingText("+50", player.x + player.width / 2, player.y, "orange");
                        } else {
                            if (!inverted) {
                                if (player.y < obs.y + obs.height && player.y + player.height > obs.y) {
                                    player.y = obs.y + obs.height;
                                    player.dy = 0;
                                    player.jumps = 0;
                                }
                            } else {
                                if (player.y <= obs.y + obs.height && player.y >= obs.y + obs.height + player.dy - gravity) {
                                    player.y = obs.y + obs.height;
                                    player.dy = 0;
                                    player.jumps = 0;
                                } else if (player.y < obs.y + obs.height) {
                                    if (vidas > 0) {
                                        vidas--;
                                        invincible = true;
                                        invincibleTimer = 60;
                                    } else {
                                        gameOver = true;
                                    }
                                }
                            }
                        }
                    }
                } else if (obs.type === "jumpPad" || obs.type === "jumpPadTop") {
                    ctx.fillStyle = "yellow";
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                    let padStrength = canvas.height * 0.045;

                    if (obs.type === "jumpPad") {
                        if (player.x + player.width > obs.x &&
                            player.x < obs.x + obs.width &&
                            player.y + player.height > obs.y &&
                            player.y + player.height < obs.y + obs.height + 10) {
                            player.dy = -padStrength;
                            player.jumps = 2;
                        }
                    } else {
                        if (player.x + player.width > obs.x &&
                            player.x < obs.x + obs.width &&
                            player.y < obs.y + obs.height &&
                            player.y + player.height > obs.y) {
                            player.dy = inverted ? padStrength : -padStrength;
                            player.jumps = 2;
                        }
                    }
                }





                if (obs.x + obs.width < 0) {
                    obstacles.splice(i, 1);
                    i--;
                    score += gameSpeed;
                }
            }

            ctx.textAlign = "left";
            ctx.fillStyle = "white";
            ctx.font = canvas.height * 0.03 + "px sans-serif";
            ctx.fillText("Puntaje: " + Math.floor(score) + " Saltos: " + saltos + " Monedas: " + monedas + " Vidas Extra: " + vidas + " Monedas Totales: " + dinero, 20, groundY + canvas.height * 0.05);

            if (invincible) {
                let alpha = getBlinkAlpha(invincibleTimer);
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha.toFixed(2)})`; // gold con alpha variable
                ctx.font = canvas.height * 0.035 + "px sans-serif";
                ctx.textAlign = "right";
                ctx.fillText("Invencible: " + (invincibleTimer / 60).toFixed(1) + "s", canvas.width - 20, 30);
            }

            if (tripleJumpActive) {
                let alpha = getBlinkAlpha(tripleJumpTimer);
                ctx.fillStyle = `rgba(0, 191, 255, ${alpha.toFixed(2)})`; // deepskyblue con alpha variable
                ctx.font = canvas.height * 0.035 + "px sans-serif";
                ctx.textAlign = "right";
                ctx.fillText("Triple Salto: " + (tripleJumpTimer / 60).toFixed(1) + "s", canvas.width - 20, 60);
            }



            frame++;
            updateFloatingTexts();
            requestAnimationFrame(update);
            score += 0.042;

            // Guarda el mejor puntaje
            if (score > bestScore) {
                bestScore = Math.floor(score);
                localStorage.setItem("bestScore", bestScore);
            }

            // Guarda la mejor cantidad de monedas también
            if (monedas > bestCoins) {
                bestCoins = monedas;
                localStorage.setItem("bestCoins", bestCoins);
            }

            if (saltos > bestSaltos) {
                bestSaltos = saltos;
                localStorage.setItem("bestSaltos", bestSaltos);
            }


        }

        update();
        createRain();








    </script>

</body>

</html>