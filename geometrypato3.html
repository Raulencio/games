<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Geometry Duck III</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #111;
        }

        canvas {
            display: block;
            background: linear-gradient(#111, #222);
        }
    </style>
</head>

<body>
    <canvas id="game"></canvas>



    <script src="js/skrips.js"></script>
    <script>

        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        let player = { x: 0, y: 0, width: 0, height: 0, dy: 0, jumps: 0, maxJumps: 2 };
        let gravity = 0;
        let jumpStrength = 0;

        let tripleJumpActive = false;
        let tripleJumpTimer = 0;
        let tripleJumpOrbs = [];

        let obstacles = [];
        let orbs = [];
        let particles = [];
        let speedOrbs = [];

        let monedas = 0;
        let coins = []; // lista de monedas



        let frame = 0;
        let gameOver = false;
        let inverted = false;

        let score = 0;
        let saltos = 0;
        let gameSpeed = 5;

        let groundY = 0;
        const ceilingY = 0;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            groundY = canvas.height * 0.8;

            player.width = canvas.width * 0.025;
            player.height = canvas.height * 0.05;
            player.x = canvas.width * 0.0625;
            player.y = groundY - player.height;

            gravity = canvas.height * 0.002;
            jumpStrength = -canvas.height * 0.03;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        document.addEventListener("keydown", e => {
            if (e.code === "Space" && player.jumps < player.maxJumps && !gameOver) {
                player.dy = inverted ? -jumpStrength : jumpStrength;
                player.jumps++; saltos++;
            }
            if (e.code === "Space" && gameOver) {
                location.reload();
            }
        });

        canvas.addEventListener("mousedown", () => {
            if (!gameOver && player.jumps < player.maxJumps) {
                player.dy = inverted ? -jumpStrength : jumpStrength;
                player.jumps++; saltos++;
            }
            if (gameOver) {
                location.reload();
            }
        });

        canvas.addEventListener("touchstart", e => {
            e.preventDefault();
            if (!gameOver && player.jumps < player.maxJumps) {
                player.dy = inverted ? -jumpStrength : jumpStrength;
                player.jumps++; saltos++;
            }
            if (gameOver) {
                location.reload();
            }
        }, { passive: false });

        function drawTriangle(x, y, width, height) {
            ctx.beginPath();
            ctx.moveTo(x, y + height);
            ctx.lineTo(x + width / 2, y);
            ctx.lineTo(x + width, y + height);
            ctx.closePath();
            ctx.fill();
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 24; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: Math.random() * 4 - 2,
                    dy: Math.random() * 4 - 2,
                    life: 30,
                    color: color
                });
            }
        }

        let bestScore = localStorage.getItem("bestScore") || 0;

        let bestCoins = localStorage.getItem("bestCoins") || 0;




        let rainDrops = [];

        function createRain() {
            // Crear gotas de lluvia al azar a lo ancho del canvas
            for (let i = 0; i < 15; i++) {
                rainDrops.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * -canvas.height, // empezar arriba fuera de pantalla
                    length: 10 + Math.random() * 10,
                    speed: 4 + Math.random() * 4
                });
            }
        }

        function updateRain() {
            ctx.strokeStyle = "rgba(174,194,224,0.5)";
            ctx.lineWidth = 1;
            ctx.lineCap = "round";

            for (let i = 0; i < rainDrops.length; i++) {
                let drop = rainDrops[i];
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x, drop.y + drop.length);
                ctx.stroke();

                drop.y += drop.speed;

                if (drop.y > groundY) {
                    drop.y = Math.random() * -canvas.height; // reaparece arriba
                    drop.x = Math.random() * canvas.width;
                }
            }
        }











        function update() {
            if (gameOver) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = "#888";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, ceilingY);
            ctx.lineTo(canvas.width, ceilingY);
            ctx.stroke();

            for (let i = 0; i < particles.length; i++) {
                let p = particles[i];
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 2, 2);
                p.x += p.dx;
                p.y += p.dy;
                p.life--;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                    i--;
                }
            }

            player.dy += inverted ? -gravity : gravity;
            player.y += player.dy;

            if (!inverted && player.y + player.height > groundY) {
                player.y = groundY - player.height;
                player.dy = 0;
                player.jumps = 0;
            } else if (inverted && player.y < ceilingY) {
                player.y = ceilingY;
                player.dy = 0;
                player.jumps = 0;
            }

            updateRain();


            ctx.fillStyle = tripleJumpActive ? "gold" : "green";
            ctx.fillRect(player.x, player.y, player.width, player.height);

            if (tripleJumpActive) {
                tripleJumpTimer--;
                if (tripleJumpTimer <= 0) {
                    tripleJumpActive = false;
                    player.maxJumps = 2;
                }
            }

            if (frame % 60 === 0) {
                let cantidad = Math.floor(Math.random() * 3) + 3;
                for (let c = 0; c < cantidad; c++) {
                    let distancia = c * canvas.width * 0.075;
                    let type = Math.floor(Math.random() * 8);
                    let width = canvas.width * 0.025;
                    let height = canvas.height * 0.1;

                    if (type === 0) {
                        obstacles.push({ x: canvas.width + distancia, y: groundY - height, width, height, type: "spike" });
                    } else if (type === 1) {
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width, height, type: "spikeTop" });
                    } else if (type === 2 || type === 3) {
                        let blockHeight = type === 2 ? canvas.height * 0.05 : canvas.height * 0.15;
                        obstacles.push({ x: canvas.width + distancia, y: groundY - blockHeight, width: width * 1.5, height: blockHeight, type: "block" });
                    } else if (type === 4) {
                        obstacles.push({ x: canvas.width + distancia, y: groundY - canvas.height * 0.025, width: width * 2, height: canvas.height * 0.025, type: "jumpPad" });
                    } else if (type === 5) {
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width: width * 2, height: canvas.height * 0.025, type: "jumpPadTop" });
                    } else if (type === 6 || type === 7) {
                        let blockHeight = canvas.height * (0.05 + Math.random() * 0.05);
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width: width * 1.5, height: blockHeight, type: "blockTop" });
                    }
                }
            }



            if (frame % 250 === 0) { // una moneda
                let coinY = Math.random() * (groundY - canvas.height * 0.1) + canvas.height * 0.05; // posición Y aleatoria entre algo arriba del suelo y un poco arriba
                coins.push({ x: canvas.width + 600, y: coinY, radius: 15 });
            }


            if (frame % 200 === 0) { //orbe de gravedad
                let orbY = (canvas.height / 2) - 40;
                orbs.push({ x: canvas.width, y: orbY, radius: 10 });
            }
            if (frame % 500 === 0) { //orbe de velocidad
                let orbY = (canvas.height / 2) - 40;
                speedOrbs.push({ x: canvas.width + 200, y: orbY, radius: 10 });
            }
            if (frame % 800 === 0) { //power up triple salto
                let orbY = (canvas.height / 2) - 40;
                tripleJumpOrbs.push({ x: canvas.width + 400, y: orbY, radius: 10 });
            }


            ctx.fillStyle = "yellow";
            for (let i = 0; i < coins.length; i++) {
                let coin = coins[i];
                coin.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(coin.x, coin.y, coin.radius, 0, Math.PI * 2);
                ctx.fill();

                if (
                    player.x < coin.x + coin.radius &&
                    player.x + player.width > coin.x - coin.radius &&
                    player.y < coin.y + coin.radius &&
                    player.y + player.height > coin.y - coin.radius
                ) {
                    monedas++;
                    coins.splice(i, 1);
                    i--;
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "yellow");
                }
            }


            ctx.fillStyle = "gold";
            for (let i = 0; i < tripleJumpOrbs.length; i++) {
                let orb = tripleJumpOrbs[i];
                orb.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                if (player.x < orb.x + orb.radius && player.x + player.width > orb.x - orb.radius && player.y < orb.y + orb.radius && player.y + player.height > orb.y - orb.radius) {
                    tripleJumpActive = true;
                    tripleJumpTimer = 800;
                    player.maxJumps = 3;
                    tripleJumpOrbs.splice(i, 1);
                    i--;
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "gold");
                }
            }

            ctx.fillStyle = "cyan";
            for (let i = 0; i < orbs.length; i++) {
                let orb = orbs[i];
                orb.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                if (player.x < orb.x + orb.radius && player.x + player.width > orb.x - orb.radius && player.y < orb.y + orb.radius && player.y + player.height > orb.y - orb.radius) {
                    inverted = !inverted;
                    orbs.splice(i, 1);
                    i--;
                    player.dy = 0;
                    player.jumps = 0;
                    createParticles(player.x + player.width, player.y + player.height, "cyan");
                }
            }

            ctx.fillStyle = "magenta";
            for (let i = 0; i < speedOrbs.length; i++) {
                let orb = speedOrbs[i];
                orb.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                if (player.x < orb.x + orb.radius && player.x + player.width > orb.x - orb.radius && player.y < orb.y + orb.radius && player.y + player.height > orb.y - orb.radius) {
                    gameSpeed += 1;
                    speedOrbs.splice(i, 1);
                    i--;
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "magenta");
                }
            }

            for (let i = 0; i < obstacles.length; i++) {
                let obs = obstacles[i];
                obs.x -= gameSpeed;

                if (obs.type === "spike" || obs.type === "spikeTop") {
                    ctx.fillStyle = "lime";

                    if (obs.type === "spike") {
                        // Triángulo en suelo
                        ctx.beginPath();
                        ctx.moveTo(obs.x, obs.y + obs.height);
                        ctx.lineTo(obs.x + obs.width / 2, obs.y);
                        ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Triángulo invertido en techo
                        ctx.beginPath();
                        ctx.moveTo(obs.x, obs.y);
                        ctx.lineTo(obs.x + obs.width / 2, obs.y + obs.height);
                        ctx.lineTo(obs.x + obs.width, obs.y);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Si toca pincho, pierde
                    if (player.x < obs.x + obs.width &&
                        player.x + player.width > obs.x &&
                        player.y < obs.y + obs.height &&
                        player.y + player.height > obs.y) {
                        gameOver = true;
                    }

                } else if (obs.type === "block") {
                    ctx.fillStyle = "orange";
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                    if (player.x + player.width > obs.x && player.x < obs.x + obs.width) {
                        if (!inverted) {
                            // Deslizar sobre bloque suelo
                            if (player.y + player.height > obs.y && player.y + player.height <= obs.y + player.dy + gravity) {
                                player.y = obs.y - player.height;
                                player.dy = 0;
                                player.jumps = 0;
                            } else if (player.y + player.height > obs.y) {
                                gameOver = true;
                            }
                        } else {
                            // Deslizar sobre bloque techo (gravedad invertida)
                            if (player.y < obs.y + obs.height && player.y >= obs.y + obs.height + player.dy - gravity) {
                                player.y = obs.y + obs.height;
                                player.dy = 0;
                                player.jumps = 0;
                            } else if (player.y < obs.y + obs.height && player.y + player.height > obs.y + obs.height) {
                                gameOver = true;
                            }
                        }
                    }

                } else if (obs.type === "blockTop") {
                    ctx.fillStyle = "orange";
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                    if (player.x + player.width > obs.x && player.x < obs.x + obs.width) {
                        if (!inverted) {
                            // Deslizar sobre bloque techo en gravedad normal
                            if (player.y < obs.y + obs.height && player.y + player.height > obs.y) {
                                player.y = obs.y + obs.height;
                                player.dy = 0;
                                player.jumps = 0;
                            }
                        } else {
                            // Deslizar sobre bloque suelo en gravedad invertida
                            if (player.y <= obs.y + obs.height && player.y >= obs.y + obs.height + player.dy - gravity) {
                                player.y = obs.y + obs.height;
                                player.dy = 0;
                                player.jumps = 0;
                            } else if (player.y < obs.y + obs.height) {
                                gameOver = true;
                            }
                        }
                    }

                } else if (obs.type === "jumpPad" || obs.type === "jumpPadTop") {
                    ctx.fillStyle = "yellow";
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                    if (obs.type === "jumpPad") {
                        if (player.x + player.width > obs.x &&
                            player.x < obs.x + obs.width &&
                            player.y + player.height > obs.y &&
                            player.y + player.height < obs.y + obs.height + 10) {
                            player.dy = -20;
                            player.jumps = 2;
                        }
                    } else {
                        if (player.x + player.width > obs.x &&
                            player.x < obs.x + obs.width &&
                            player.y < obs.y + obs.height &&
                            player.y + player.height > obs.y) {
                            player.dy = inverted ? 20 : -20;
                            player.jumps = 2;
                        }
                    }
                }

                if (obs.x + obs.width < 0) {
                    obstacles.splice(i, 1);
                    i--;
                    score += gameSpeed;
                }
            }

            ctx.textAlign = "left";
            ctx.fillStyle = "white";
            ctx.font = canvas.height * 0.03 + "px sans-serif";
            ctx.fillText("Puntaje: " + score + " Saltos: " + saltos + " Monedas: " + monedas, 20, groundY + canvas.height * 0.05);

            if (gameOver) {
                if (score > bestScore) {
                    bestScore = score;
                    localStorage.setItem("bestScore", bestScore);
                }

                if (monedas > bestCoins) {
                    bestCoins = monedas;
                    localStorage.setItem("bestCoins", bestCoins);
                }


                ctx.textAlign = "center";
                ctx.fillStyle = "red";
                ctx.font = canvas.height * 0.08 + "px sans-serif";
                ctx.fillText("Geometry Duck", canvas.width / 2, canvas.height / 2 - canvas.height * 0.05);
                ctx.font = canvas.height * 0.04 + "px sans-serif";
                ctx.fillText("Presiona Patos para Iniciar", canvas.width / 2, canvas.height / 2);
                ctx.fillStyle = "white";
                ctx.fillText("Puntaje máximo: " + bestScore, canvas.width / 2, canvas.height / 2 + canvas.height * 0.05);
                ctx.fillText("Monedas máximas: " + bestCoins, canvas.width / 2, canvas.height / 2 + canvas.height * 0.10);

            }


            frame++;
            if (!gameOver) requestAnimationFrame(update);
        }

        update();
        createRain();
    </script>

</body>

</html>