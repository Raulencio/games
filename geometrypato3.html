<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Geometry Duck III</title>
    <style>
        body {
            margin: 0;
            background: #111;
            overflow: hidden;
        }

        canvas {
            display: block;
            margin: 0 auto;
            background: linear-gradient(#111, #222);
        }
    </style>
</head>

<body>
    <canvas id="game" width="800" height="400"></canvas>



    <script src="js/skrips.js"></script>

    <script>

        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        let player = { x: 50, y: 300, width: 20, height: 20, dy: 0, jumps: 0, maxJumps: 2 };
        let gravity = 0.8;
        let jumpStrength = -12;


        let tripleJumpActive = false;
        let tripleJumpTimer = 0;
        let tripleJumpOrbs = []; // lista de orbes de triple salto


        let obstacles = [];
        let orbs = [];
        let particles = [];
        let speedOrbs = [];


        let frame = 0;
        let gameOver = false;
        let inverted = false;

        let score = 0; // ⭐ Nuevo: puntaje inicializado en 0

        var saltos = 0;
        var gameSpeed = 5;



        const groundY = 320;
        const ceilingY = 0;

        document.addEventListener("keydown", e => {
            if (e.code === "Space" && player.jumps < player.maxJumps && !gameOver) {
                player.dy = inverted ? -jumpStrength : jumpStrength;
                player.jumps++; saltos++;
            }
            if (e.code === "Space" && gameOver) {
                location.reload();
            }
        });


        canvas.addEventListener("mousedown", () => {
            if (!gameOver && player.jumps < player.maxJumps) {
                player.dy = inverted ? -jumpStrength : jumpStrength;
                player.jumps++; saltos++;
            }
            if (gameOver) {
                location.reload();
            }
        });

        canvas.addEventListener("touchstart", e => {
            e.preventDefault(); // evitar scroll al tocar
            if (!gameOver && player.jumps < player.maxJumps) {
                player.dy = inverted ? -jumpStrength : jumpStrength;
                player.jumps++; saltos++;
            }
            if (gameOver) {
                location.reload();
            }
        }, { passive: false });




        function drawTriangle(x, y, width, height) {
            ctx.beginPath();
            ctx.moveTo(x, y + height);
            ctx.lineTo(x + width / 2, y);
            ctx.lineTo(x + width, y + height);
            ctx.closePath();
            ctx.fill();
        }


        function createParticles(x, y, color) {
            for (let i = 0; i < 24; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: Math.random() * 4 - 2,
                    dy: Math.random() * 4 - 2,
                    life: 30,
                    color: color
                });
            }
        }


        let bestScore = localStorage.getItem("bestScore") || 0;



        function update() {
            if (gameOver) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Dibujar suelo y techo
            ctx.strokeStyle = "#888";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, ceilingY);
            ctx.lineTo(canvas.width, ceilingY);
            ctx.stroke();


            for (let i = 0; i < particles.length; i++) {
                let p = particles[i];
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 2, 2);
                p.x += p.dx;
                p.y += p.dy;
                p.life--;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                    i--;
                }
            }



            // Actualizar player física
            player.dy += inverted ? -gravity : gravity;
            player.y += player.dy;

            // Límite suelo y techo según gravedad
            if (!inverted && player.y + player.height > groundY) {
                player.y = groundY - player.height;
                player.dy = 0;
                player.jumps = 0;
            } else if (inverted && player.y < ceilingY) {
                player.y = ceilingY;
                player.dy = 0;
                player.jumps = 0;
            }

            if (tripleJumpActive) {
                ctx.fillStyle = "gold"; // color dorado mientras triple salto está activo
            } else {
                ctx.fillStyle = "green"; // color normal
            }


            if (tripleJumpActive) {
                tripleJumpTimer--;
                if (tripleJumpTimer <= 0) {
                    tripleJumpActive = false;
                    player.maxJumps = 2; // volver a doble salto normal
                }
            }



            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Generar obstáculos consecutivos en suelo y techo
            if (frame % 60 === 0) {
                let cantidad = Math.floor(Math.random() * 3) + 3;
                for (let c = 0; c < cantidad; c++) {
                    let distancia = c * 60;
                    let type = Math.floor(Math.random() * 8);
                    if (type === 0) {
                        // Pincho en suelo
                        obstacles.push({ x: canvas.width + distancia, y: groundY - 40, width: 20, height: 40, type: "spike" });
                    } else if (type === 1) {
                        // Pincho en techo
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width: 20, height: 40, type: "spikeTop" });
                    } else if (type === 2 || type === 3) {
                        let height = type === 2 ? 20 : 60;
                        // Bloque en suelo
                        obstacles.push({ x: canvas.width + distancia, y: groundY - height, width: 30, height: height, type: "block" });
                    } else if (type === 4) {
                        // Pad de salto
                        obstacles.push({ x: canvas.width + distancia, y: groundY - 10, width: 40, height: 10, type: "jumpPad" });
                    } else if (type === 5) {
                        // Pad de salto
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width: 40, height: 10, type: "jumpPadTop" });
                    }
                    else if (type === 6 || type === 7) {
                        let height = 20 + Math.floor(Math.random() * 40);
                        // Bloque en techo
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width: 30, height: height, type: "blockTop" });
                    }

                }
            }


            // Generar orbes de gravedad
            if (frame % 200 === 0) {
                // Orbe siempre en el centro vertical del canvas
                let orbY = (canvas.height / 2) - 40;
                orbs.push({ x: canvas.width, y: orbY, radius: 10 });
            }
            if (frame % 500 === 0) { // cada 600 frames (~10s)
                let orbY = (canvas.height / 2) - 40;
                speedOrbs.push({ x: canvas.width + 200, y: orbY, radius: 10 });
            }
            // Generar orbe de triple salto cada 800 frames (~13s)
            if (frame % 800 === 0) {
                let orbY = (canvas.height / 2) - 40;
                tripleJumpOrbs.push({ x: canvas.width + 400, y: orbY, radius: 10 });
            }




            // Dibujar y actualizar orbes


            ctx.fillStyle = "gold";
            for (let i = 0; i < tripleJumpOrbs.length; i++) {
                let orb = tripleJumpOrbs[i];
                orb.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                // Colisión con jugador
                if (player.x < orb.x + orb.radius &&
                    player.x + player.width > orb.x - orb.radius &&
                    player.y < orb.y + orb.radius &&
                    player.y + player.height > orb.y - orb.radius) {

                    tripleJumpActive = true;
                    tripleJumpTimer = 800; // 20 segundos si tu juego corre a 60fps
                    player.maxJumps = 3; // activar triple salto

                    tripleJumpOrbs.splice(i, 1);
                    i--;

                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "gold");
                }
            }


            ctx.fillStyle = "cyan";
            for (let i = 0; i < orbs.length; i++) {
                let orb = orbs[i];
                orb.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                // Colisión con jugador (círculo-rectángulo simple)
                if (player.x < orb.x + orb.radius &&
                    player.x + player.width > orb.x - orb.radius &&
                    player.y < orb.y + orb.radius &&
                    player.y + player.height > orb.y - orb.radius) {
                    inverted = !inverted;
                    orbs.splice(i, 1);
                    i--;
                    // Ajustar player posición para evitar quedar pegado fuera del límite
                    if (inverted) {
                        if (player.y < ceilingY) player.y = ceilingY;
                    } else {
                        if (player.y + player.height > groundY) player.y = groundY - player.height;
                    }
                    // Resetear velocidad y saltos al cambiar gravedad
                    player.dy = 0;
                    player.jumps = 0;

                    createParticles(player.x + player.width, player.y + player.height, "cyan");
                }

            }


            ctx.fillStyle = "magenta";
            for (let i = 0; i < speedOrbs.length; i++) {
                let orb = speedOrbs[i];
                orb.x -= gameSpeed;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                // Colisión con jugador
                if (player.x < orb.x + orb.radius &&
                    player.x + player.width > orb.x - orb.radius &&
                    player.y < orb.y + orb.radius &&
                    player.y + player.height > orb.y - orb.radius) {
                    gameSpeed += 1; // aumenta la velocidad en +1
                    speedOrbs.splice(i, 1);
                    i--;

                    // 🌠 Efecto de partículas al recogerlo
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "magenta");
                }
            }



            // Dibujar y actualizar obstáculos
            for (let i = 0; i < obstacles.length; i++) {
                let obs = obstacles[i];
                obs.x -= gameSpeed;

                if (obs.type === "spike") {
                    ctx.fillStyle = "lime";
                    drawTriangle(obs.x, obs.y, obs.width, obs.height);

                    if (player.x < obs.x + obs.width &&
                        player.x + player.width > obs.x &&
                        player.y < obs.y + obs.height &&
                        player.y + player.height > obs.y) {
                        gameOver = true;
                    }

                } else if (obs.type === "spikeTop") {
                    ctx.fillStyle = "lime";
                    // Dibuja el triángulo invertido para pincho en techo
                    ctx.beginPath();
                    ctx.moveTo(obs.x, obs.y);
                    ctx.lineTo(obs.x + obs.width / 2, obs.y + obs.height);
                    ctx.lineTo(obs.x + obs.width, obs.y);
                    ctx.closePath();
                    ctx.fill();

                    if (player.x < obs.x + obs.width &&
                        player.x + player.width > obs.x &&
                        player.y < obs.y + obs.height &&
                        player.y + player.height > obs.y) {
                        gameOver = true;
                    }

                } else if (obs.type === "block") {
                    ctx.fillStyle = "orange";
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                    if (player.x + player.width > obs.x &&
                        player.x < obs.x + obs.width) {

                        if (!inverted) {
                            if (player.y + player.height > obs.y && player.y + player.height <= obs.y + player.dy + gravity) {
                                player.y = obs.y - player.height;
                                player.dy = 0;
                                player.jumps = 0;
                            } else if (player.y + player.height > obs.y) {
                                gameOver = true;
                            }
                        } else {
                            if (player.y < obs.y + obs.height && player.y >= obs.y + obs.height + player.dy - gravity) {
                                player.y = obs.y + obs.height;
                                player.dy = 0;
                                player.jumps = 0;
                            } else if (player.y < obs.y + obs.height && player.y + player.height > obs.y + obs.height) {
                                gameOver = true;
                            }
                        }
                    }

                } else if (obs.type === "blockTop") {
                    ctx.fillStyle = "orange";
                    // Dibuja bloque en techo
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                    if (player.x + player.width > obs.x &&
                        player.x < obs.x + obs.width) {

                        if (!inverted) {
                            // En gravedad normal, colisión si jugador toca bloque de arriba
                            if (player.y < obs.y + obs.height &&
                                player.y + player.height > obs.y) {
                                gameOver = true;
                            }
                        } else {
                            // En gravedad invertida, puede "aterrizar" debajo del bloque
                            if (player.y <= obs.y + obs.height && player.y >= obs.y + obs.height + player.dy - gravity) {
                                player.y = obs.y + obs.height;
                                player.dy = 0;
                                player.jumps = 0;
                            } else if (player.y < obs.y + obs.height) {
                                gameOver = true;
                            }
                        }
                    }
                }
                else if (obs.type === "jumpPad") {
                    ctx.fillStyle = "yellow";
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                    // Efecto de salto alto al tocar
                    if (player.x + player.width > obs.x &&
                        player.x < obs.x + obs.width &&
                        player.y + player.height > obs.y &&
                        player.y + player.height < obs.y + obs.height + 10) {
                        player.dy = -20; // impulso de salto más alto
                        player.jumps = 2; // cuenta como un salto usado para no poder saltar infinitamente
                    }
                } else if (obs.type === "jumpPadTop") {
                    ctx.fillStyle = "yellow";
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                    // Efecto de salto alto al tocar
                    if (player.x + player.width > obs.x &&
                        player.x < obs.x + obs.width &&
                        player.y < obs.y + obs.height &&
                        player.y + player.height > obs.y) {

                        if (inverted) {
                            player.dy = 20; // impulso hacia abajo si la gravedad está invertida
                        } else {
                            player.dy = -20; // impulso hacia arriba si la gravedad es normal
                        }
                        player.jumps = 2; // cuenta como un salto usado para evitar saltos infinitos
                    }
                }




                if (obs.x + obs.width < 0) {
                    obstacles.splice(i, 1);
                    i--;
                    score += gameSpeed;
                }

            }
            ctx.fillStyle = "white";
            ctx.font = "20px sans-serif";
            ctx.fillText("Puntaje: " + score + " Saltos: " + saltos, 20, 350);

            // Mensaje de muerte
            if (gameOver) {
                ctx.fillStyle = "red";
                ctx.font = "48px sans-serif";
                ctx.fillText("Geometry Duck", 240, 200);
                ctx.font = "24px sans-serif";
                ctx.fillText("Presiona Patos para Iniciar", 260, 250);
                if (score > bestScore) {
                    bestScore = score;
                    localStorage.setItem("bestScore", bestScore);
                }
                ctx.fillStyle = "white";
                ctx.fillText("Puntaje máximo: " + bestScore, 280, 290);
            }

            frame++;
            if (!gameOver) requestAnimationFrame(update);
        }



        update();



    </script>
</body>

</html>