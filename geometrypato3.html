<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Geometry Duck III</title>

    <link rel="icon" href="pato.png" type="image/png">

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #111;
        }

        canvas {
            display: block;
            background: linear-gradient(#005163, #026159);
        }

        #botonera {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: space-around;
            padding: 1px 0;
            z-index: 10;
        }

        #botonera button {
            background: #04a;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        #botonera button:hover {
            background: #07c;
        }
    </style>
</head>

<body>
    <canvas id="game"></canvas>

    <div id="botonera">
        <button id="btn1" onclick="togglePause()">Pausa </button>
        <button id="btn2" onclick="gravedad()">Gravedad</button>
        <button id="btn3" onclick="velocidad()">Velocidad</button>
        <button id="btn4" onclick="invencibilidad()">Invencibilidad</button>
        <button id="btn5" onclick="tripleSaltoActivo()">Triple Salto</button>
        <button id="btn10" onclick="abrirtienda()">Tienda</button>
    </div>

    <script src="js/skrips.js"></script>
    <script>

        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");


        let timeOfDay = 0;

        let player = { x: 0, y: 0, width: 0, height: 0, dy: 0, jumps: 0, maxJumps: 2 };
        let gravity = 0;
        let jumpStrength = 0;

        let tripleJumpActive = false;
        let tripleJumpTimer = 0;
        let tripleJumpOrbs = [];

        let obstacles = [];
        let orbs = [];
        let particles = [];
        let speedOrbs = [];

        let monedas = 0;
        let coins = []; // lista de monedas

        let vidas = 0;
        let heartOrbs = [];


        let invincible = false;
        let invincibleTimer = 0;
        let shieldOrbs = [];




        let frame = 0;

        let gameOver = true;
        let inverted = false;

        let score = 0;
        let saltos = 0;
        let gameSpeed = 5;

        let groundY = 0;
        const ceilingY = 0;


        let paused = false;

        function togglePause() {
            paused = !paused;
        }

        function gravedad() {
            inverted = !inverted;

        }
        function velocidad() {
            gameSpeed += 1;
        }

        function invencibilidad() {
            invincible = !invincible;
            if (invincible) {
                invincibleTimer = 300000;
            } else {
                invincibleTimer = 0;
            }

        }

        function tripleSaltoActivo() {

            tripleJumpActive = !tripleJumpActive;

            if (tripleJumpActive) {
                tripleJumpTimer = 300000;
                player.maxJumps = 3;
            } else {
                tripleJumpTimer = 0;
                player.maxJumps = 2;
            }

        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            groundY = canvas.height * 0.8;

            player.width = canvas.width * 0.025;
            player.height = canvas.height * 0.05;
            player.x = canvas.width * 0.0625;
            player.y = groundY - player.height;

            gravity = canvas.height * 0.002;
            jumpStrength = -canvas.height * 0.03;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        canvas.addEventListener("mousedown", () => {
            if (gameOver) {
                resetGame();
                return;
            }
            if (player.jumps < player.maxJumps) {
                player.dy = inverted ? -jumpStrength : jumpStrength;
                player.jumps++;
                saltos++;

                if (isEgg) {
                    isEgg = false;
                    console.log("El huevo se rompi√≥ y naci√≥ el pato.");
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, skins[skinActual].colorHuevo);
                }
            }
        });

        document.addEventListener("keydown", e => {
            if (gameOver && e.code === "Space") {
                resetGame();
                return;
            }
            if (e.code === "Space" && player.jumps < player.maxJumps) {
                player.dy = inverted ? -jumpStrength : jumpStrength;
                player.jumps++;
                saltos++;

                if (isEgg) {
                    isEgg = false; // üê£ Romper huevo al primer salto
                    console.log("El huevo se rompi√≥ y naci√≥ el pato.");
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, skins[skinActual].colorHuevo);
                }
            }
        });

        canvas.addEventListener("touchstart", e => {
            e.preventDefault();
            if (gameOver) {
                resetGame();
                return;
            }
            if (player.jumps < player.maxJumps) {
                player.dy = inverted ? -jumpStrength : jumpStrength;
                player.jumps++;
                saltos++;

                if (isEgg) {
                    isEgg = false;
                    console.log("El huevo se rompi√≥ y naci√≥ el pato.");
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, skins[skinActual].colorHuevo);
                }
            }
        }, { passive: false });


        function drawTriangle(x, y, width, height) {
            ctx.beginPath();
            ctx.moveTo(x, y + height);
            ctx.lineTo(x + width / 2, y);
            ctx.lineTo(x + width, y + height);
            ctx.closePath();
            ctx.fill();
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 24; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: Math.random() * 4 - 2,
                    dy: Math.random() * 4 - 2,
                    life: 30,
                    color: color
                });
            }
        }

        let bestScore = localStorage.getItem("bestScore") || 0;

        let bestCoins = localStorage.getItem("bestCoins") || 0;

        let bestSaltos = localStorage.getItem("bestSaltos") || 0;

        let dinero = parseInt(localStorage.getItem("dinero")) || 0;



        let rainDrops = [];

        function createRain(cantidad) {
            rainDrops = []; // Reiniciar el arreglo para no acumular gotas viejas
            for (let i = 0; i < cantidad; i++) {
                rainDrops.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * -canvas.height,
                    length: 10 + Math.random() * 10,
                    speed: 4 + Math.random() * 4
                });
            }
        }


        function updateRain() {
            ctx.strokeStyle = "rgba(174,194,224,0.5)";
            ctx.lineWidth = 1;
            ctx.lineCap = "round";

            for (let i = 0; i < rainDrops.length; i++) {
                let drop = rainDrops[i];
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x, drop.y + drop.length);
                ctx.stroke();

                drop.y += drop.speed;

                if (drop.y > groundY) {
                    drop.y = Math.random() * -canvas.height; // reaparece arriba
                    drop.x = Math.random() * canvas.width;
                }
            }
        }


        let botonesTienda = [];

        function comprarVida() {
            if (dinero >= 1) {
                dinero -= 1;
                vidas++;
                localStorage.setItem("dinero", dinero);
            }
        }

        function comprarInvencibilidad() {
            if (dinero >= 3) {
                dinero -= 3;
                invincible = true;
                invincibleTimer = 600;
                localStorage.setItem("dinero", dinero);
            }
        }

        function comprarTripleSalto() {
            if (dinero >= 2) {
                dinero -= 2;
                tripleJumpActive = true;
                tripleJumpTimer = 800;
                player.maxJumps = 3;
                localStorage.setItem("dinero", dinero);
            }
        }



        let tiendaAbierta = false;
        function abrirtienda() {

            if (!gameOver) {
                tiendaAbierta = !tiendaAbierta;
            }

        }


        document.addEventListener("keydown", (e) => {
            if (e.code === "KeyT" && !gameOver) {
                tiendaAbierta = !tiendaAbierta;
            }
        });



        let isEgg = true; // ü•ö El personaje inicia como huevo
        let eggRotation = 0;


        const skins = [
            { id: 0, nombre: "Pato cl√°sico", imgSrc: "pato.png", precio: 0, comprado: true, colorHuevo: "white", colorPato: "yellow" },
            { id: 1, nombre: "Pato ninja", imgSrc: "pato_ninja.png", precio: 15, comprado: false, colorHuevo: "black", colorPato: "lightgray" },
            { id: 2, nombre: "Pato robot", imgSrc: "pato_robot.png", precio: 20, comprado: false, colorHuevo: "lightgray", colorPato: "black" },
            { id: 3, nombre: "Pato pirata", imgSrc: "pato_pirata.png", precio: 30, comprado: false, colorHuevo: "saddlebrown", colorPato: "goldenrod" },
            { id: 4, nombre: "Pato zombie", imgSrc: "pato_zombie.png", precio: 50, comprado: false, colorHuevo: "olive", colorPato: "green" },
        ];



        skins.forEach(skin => {
            skin.img = new Image();
            skin.img.src = skin.imgSrc;
        });



        // Cargar skins compradas desde localStorage
        const skinsGuardadas = JSON.parse(localStorage.getItem("skinsCompradas"));
        if (skinsGuardadas) {
            skins.forEach((s, i) => s.comprado = skinsGuardadas[i]);
        }

        // Cargar skin seleccionada
        let skinActual = parseInt(localStorage.getItem("skinActual")) || 0;

        // Solo guarda si a√∫n no exist√≠a en el almacenamiento
        if (!skinsGuardadas) {
            localStorage.setItem("skinsCompradas", JSON.stringify(skins.map(s => s.comprado)));
        }
        if (!localStorage.getItem("skinActual")) {
            localStorage.setItem("skinActual", skinActual);
        }


        function dibujarTienda() {
            botonesTienda = [];

            // Fondo semitransparente
            ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "white";
            ctx.textAlign = "center";

            // T√≠tulo
            ctx.font = `${Math.floor(canvas.height * 0.06)}px sans-serif`;
            ctx.fillText("TIENDA", canvas.width / 2, canvas.height * 0.1);

            // Monedas
            ctx.font = `${Math.floor(canvas.height * 0.04)}px sans-serif`;
            ctx.fillText(`Monedas: ${dinero}`, canvas.width / 2, canvas.height * 0.17);

            // Configuraci√≥n de columnas
            const mitadAncho = canvas.width / 2;
            const margen = canvas.width * 0.05;
            const buttonWidth = mitadAncho - margen * 2;
            const buttonHeight = canvas.height * 0.08;
            const startY = canvas.height * 0.25;
            const gap = canvas.height * 0.12;

            // üéØ MEJORAS ‚Äì columna izquierda
            ctx.font = `${Math.floor(canvas.height * 0.035)}px sans-serif`;
            ctx.fillText("Mejoras", mitadAncho / 2, startY - canvas.height * 0.05);

            const botones = [
                { texto: "+1 Vida Extra (1 moneda)", precio: 1, accion: comprarVida },
                { texto: "Invencibilidad (3 monedas)", precio: 3, accion: comprarInvencibilidad },
                { texto: "Triple Salto (2 monedas)", precio: 2, accion: comprarTripleSalto },
            ];

            botones.forEach((b, i) => {
                const x = margen;
                const y = startY + i * gap;

                ctx.fillStyle = dinero >= b.precio ? "#2ecc71" : "#7f8c8d";
                ctx.fillRect(x, y, buttonWidth, buttonHeight);

                ctx.fillStyle = "white";
                ctx.textBaseline = "middle";
                ctx.fillText(b.texto, x + buttonWidth / 2, y + buttonHeight / 2);

                botonesTienda.push({ x, y, w: buttonWidth, h: buttonHeight, accion: b.accion, precio: b.precio });
            });

            // üéØ SKINS ‚Äì columna derecha
            ctx.font = `${Math.floor(canvas.height * 0.035)}px sans-serif`;
            ctx.fillText("Skins", mitadAncho + mitadAncho / 2, startY - canvas.height * 0.05);

            skins.forEach((skin, i) => {
                const x = mitadAncho + margen;
                const y = startY + i * gap;
                const w = buttonWidth;
                const h = buttonHeight;

                // Fondo seg√∫n estado
                if (skinActual === skin.id) {
                    ctx.fillStyle = "#f39c12"; // naranja si seleccionada
                } else if (skin.comprado) {
                    ctx.fillStyle = "#2980b9"; // azul si comprada
                } else if (dinero >= skin.precio) {
                    ctx.fillStyle = "#27ae60"; // verde si se puede comprar
                } else {
                    ctx.fillStyle = "#7f8c8d"; // gris si no se puede comprar
                }

                ctx.fillRect(x, y, w, h);

                // Imagen peque√±a de la skin
                const imgSize = h * 0.8;
                ctx.drawImage(skin.img, x + 5, y + (h - imgSize) / 2, imgSize, imgSize);

                // Texto
                ctx.fillStyle = "white";
                ctx.textAlign = "left";
                let textoSkin = skin.nombre;
                if (skinActual === skin.id) {
                    textoSkin += " (Seleccionada)";
                } else if (skin.comprado) {
                    textoSkin += " (Usar)";
                } else {
                    textoSkin += ` (${skin.precio} monedas)`;
                }

                ctx.fillText(textoSkin, x + imgSize + 15, y + h / 2 + 7);

                botonesTienda.push({
                    x, y, w, h,
                    accion: () => {
                        if (!skin.comprado && dinero >= skin.precio) {
                            dinero -= skin.precio;
                            skin.comprado = true;
                            isEgg = true;
                        }
                        if (skin.comprado) {
                            skinActual = skin.id;
                            isEgg = true;
                        }

                        localStorage.setItem("skinsCompradas", JSON.stringify(skins.map(s => s.comprado)));
                        localStorage.setItem("skinActual", skinActual);
                        localStorage.setItem("dinero", dinero);
                    }
                });
            });
        }

        canvas.addEventListener("click", e => {

            if (!tiendaAbierta) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            console.log("Click en", x, y);

            if (botonesTienda) {
                console.log(botonesTienda);
                botonesTienda.forEach(b => {
                    console.log("Bot√≥n:", b);
                    if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
                        console.log("Click en bot√≥n:", b.texto);
                        b.accion();
                    }
                });
            }
        });



        canvas.addEventListener("touchstart", e => {

            if (!tiendaAbierta) return;

            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            if (botonesTienda) {
                botonesTienda.forEach(b => {
                    if (x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h) {
                        b.accion();
                        dibujarTienda(); // refresca la tienda tras la compra
                    }
                });
            }
            e.preventDefault(); // para que no haga scroll o zoom
        });



        let floatingTexts = [];

        function addFloatingText(text, x, y, color = "white", duration = 60) {
            // Ajustamos x y y para que el texto aparezca a la izquierda y un poco m√°s abajo
            const adjustedX = x - 25; // 20 p√≠xeles a la izquierda
            const adjustedY = y + 10; // 10 p√≠xeles m√°s abajo

            floatingTexts.push({ text, x: adjustedX, y: adjustedY, alpha: 1, duration, color });
        }

        function updateFloatingTexts() {
            for (let i = 0; i < floatingTexts.length; i++) {
                let ft = floatingTexts[i];
                ft.y -= 1; // asciende suavemente
                if (ft.y < 20) ft.y = 20; // evita que suba demasiado

                ft.alpha -= 1 / ft.duration; // desvanece
                ft.duration--;

                ctx.fillStyle = ft.color.includes("#")
                    ? hexToRgba(ft.color, ft.alpha)
                    : nameToRgba(ft.color, ft.alpha);

                ctx.font = "20px sans-serif";
                ctx.textAlign = "center";

                // Configurar sombra negra suave
                ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.fillText(ft.text, ft.x, ft.y);

                // Limpiar sombra para no afectar otros dibujos
                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                if (ft.duration <= 0) {
                    floatingTexts.splice(i, 1);
                    i--;
                }
            }
        }

        function hexToRgba(hex, alpha) {
            let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                return r + r + g + g + b + b;
            });

            let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ?
                `rgba(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}, ${alpha.toFixed(2)})` :
                `rgba(255,255,255,${alpha.toFixed(2)})`;
        }

        function nameToRgba(name, alpha) {
            // Crea un elemento temporal para obtener el color computado
            let temp = document.createElement("div");
            temp.style.color = name;
            document.body.appendChild(temp);

            let rgb = getComputedStyle(temp).color;
            document.body.removeChild(temp);

            // rgb puede ser "rgb(r, g, b)" o "rgba(r, g, b, a)"
            let rgbValues = rgb.match(/\d+/g);
            return rgbValues ?
                `rgba(${rgbValues[0]}, ${rgbValues[1]}, ${rgbValues[2]}, ${alpha.toFixed(2)})` :
                `rgba(255,255,255,${alpha.toFixed(2)})`;
        }


        // Funci√≥n para calcular la opacidad parpadeante seg√∫n el tiempo restante
        function getBlinkAlpha(timer, threshold = 180, blinkSpeed = 10) {
            if (timer > threshold) return 1; // opacidad total si queda mucho tiempo
            // parpadeo entre 0.2 y 1 con ciclo de blinkSpeed frames
            return 0.6 + 0.4 * Math.abs(Math.sin(timer / blinkSpeed));
        }










        /*
        
                    // Ahora usas typeIndex para crear el obst√°culo seg√∫n tu l√≥gica previa
                            === 0 "spike" 
                            === 1 "spikeTop" 
                            === 2 ||  === 3 "block" 
                            === 4 "jumpPad" 
                            === 5 "jumpPadTop"
                            === 6 ||  === 7 "blockTop" 
                            === 8 "bigRock"
                            === 9  "bigRockTop"
                            === 10 "floatingPlatform"
                            === 11 "doubleSpike"
                            === 12 "doubleSpikeTop"

             orbTypes: ["coin", "speed", "heart", "gravity", "shield", "tripleJump"],
        */

        var puntos = 0;


        let niveles = [
            {
                name: "Estanque Tranquilo",
                obstacleFrequency: 80,
                obstacleTypes: [2],
                orbTypes: ["coin", "speed"],
                hasRain: false,
                rainAmount: 0,
                gameSpeed: 5,
                requiredScore: 0,
                backgroundColors: [
                    { top: { r: 255, g: 153, b: 51 }, bottom: { r: 102, g: 204, b: 255 } },
                    { top: { r: 51, g: 153, b: 255 }, bottom: { r: 0, g: 102, b: 204 } },
                    { top: { r: 255, g: 102, b: 102 }, bottom: { r: 51, g: 51, b: 102 } },
                    { top: { r: 10, g: 10, b: 40 }, bottom: { r: 0, g: 0, b: 20 } }
                ],
                orbFrequency: {
                    heart: 1000,
                    shield: 1200,
                    coin: 250,
                    gravity: 200,
                    speed: 500,
                    tripleJump: 800
                },
                obstacleColors: {
                    spike: "green",
                    spikeTop: "green",
                    block: "sienna",
                    blockTop: "sienna",
                    jumpPad: "yellow",
                    jumpPadTop: "yellow"
                }
            },
            {
                name: "Lluvia de Medianoche",
                obstacleFrequency: 60,
                obstacleTypes: [2, 3],
                orbTypes: ["coin", "speed", "heart"],
                hasRain: true,
                rainAmount: 15,
                gameSpeed: 6,
                requiredScore: 500,
                backgroundColors: [
                    { top: { r: 20, g: 20, b: 40 }, bottom: { r: 0, g: 0, b: 20 } },
                    { top: { r: 30, g: 30, b: 60 }, bottom: { r: 10, g: 10, b: 30 } },
                    { top: { r: 20, g: 20, b: 40 }, bottom: { r: 0, g: 0, b: 20 } },
                    { top: { r: 10, g: 10, b: 20 }, bottom: { r: 0, g: 0, b: 10 } }
                ],
                orbFrequency: {
                    heart: 1000,
                    shield: 1200,
                    coin: 250,
                    gravity: 200,
                    speed: 500,
                    tripleJump: 800
                },
                obstacleColors: {
                    spike: "lightblue",
                    spikeTop: "lightblue",
                    block: "grey",
                    blockTop: "grey",
                    jumpPad: "yellow",
                    jumpPadTop: "yellow"
                }
            },
            {
                name: "Niebla Encantada",
                obstacleFrequency: 55,
                obstacleTypes: [2, 3, 6, 7],
                orbTypes: ["coin", "gravity", "speed", "heart"],
                hasRain: false,
                rainAmount: 0,
                gameSpeed: 7,
                requiredScore: 1500,
                backgroundColors: [
                    { top: { r: 180, g: 180, b: 200 }, bottom: { r: 150, g: 150, b: 170 } },
                    { top: { r: 140, g: 140, b: 160 }, bottom: { r: 100, g: 100, b: 120 } },
                    { top: { r: 120, g: 120, b: 140 }, bottom: { r: 80, g: 80, b: 100 } },
                    { top: { r: 60, g: 60, b: 80 }, bottom: { r: 30, g: 30, b: 50 } }
                ],
                orbFrequency: {
                    heart: 1000,
                    shield: 1200,
                    coin: 250,
                    gravity: 200,
                    speed: 500,
                    tripleJump: 800
                },
                obstacleColors: {
                    spike: "silver",
                    spikeTop: "silver",
                    block: "darkgrey",
                    blockTop: "darkgrey",
                    jumpPad: "yellow",
                    jumpPadTop: "yellow"
                }
            },
            {
                name: "Tormenta El√©ctrica",
                obstacleFrequency: 50,
                obstacleTypes: [4, 5, 2, 3, 6, 7],
                orbTypes: ["coin", "gravity", "speed", "heart"],
                hasRain: true,
                rainAmount: 80,
                gameSpeed: 8,
                requiredScore: 2200,
                backgroundColors: [
                    { top: { r: 40, g: 40, b: 60 }, bottom: { r: 10, g: 10, b: 20 } },
                    { top: { r: 60, g: 60, b: 90 }, bottom: { r: 20, g: 20, b: 30 } },
                    { top: { r: 30, g: 30, b: 50 }, bottom: { r: 5, g: 5, b: 10 } },
                    { top: { r: 80, g: 80, b: 110 }, bottom: { r: 40, g: 40, b: 60 } }
                ],
                orbFrequency: {
                    heart: 1000,
                    shield: 1200,
                    coin: 250,
                    gravity: 200,
                    speed: 500,
                    tripleJump: 800
                },
                obstacleColors: {
                    spike: "white",
                    spikeTop: "white",
                    block: "darkslategray",
                    blockTop: "darkslategray",
                    jumpPad: "yellow",
                    jumpPadTop: "yellow"
                }
            },
            {
                name: "Selva Profunda",
                obstacleFrequency: 60,
                obstacleTypes: [2, 3, 4, 5, 6, 7, 10],
                orbTypes: ["coin", "gravity", "speed", "heart", "shield", "tripleJump"],
                hasRain: true,
                rainAmount: 30,
                gameSpeed: 7,
                requiredScore: 3500,
                backgroundColors: [
                    { top: { r: 0, g: 100, b: 40 }, bottom: { r: 0, g: 60, b: 20 } },
                    { top: { r: 10, g: 110, b: 50 }, bottom: { r: 10, g: 70, b: 30 } },
                    { top: { r: 0, g: 90, b: 35 }, bottom: { r: 0, g: 50, b: 15 } },
                    { top: { r: 0, g: 40, b: 20 }, bottom: { r: 0, g: 20, b: 10 } }
                ],
                orbFrequency: {
                    heart: 1000,
                    shield: 1200,
                    coin: 250,
                    gravity: 200,
                    speed: 500,
                    tripleJump: 800
                },
                obstacleColors: {
                    spike: "darkgreen",
                    spikeTop: "darkgreen",
                    block: "forestgreen",
                    blockTop: "forestgreen",
                    jumpPad: "brown",
                    jumpPadTop: "brown",
                    floatingPlatform: "darkgreen"
                }
            },
            {
                name: "Volc√°n en Erupci√≥n",
                obstacleFrequency: 40,
                obstacleTypes: [0, 1, 4, 5, 12, 11],
                orbTypes: ["coin", "gravity", "speed", "heart", "shield", "tripleJump"],
                hasRain: false,
                rainAmount: 0,
                gameSpeed: 9,
                requiredScore: 5000,
                backgroundColors: [
                    { top: { r: 150, g: 50, b: 30 }, bottom: { r: 80, g: 20, b: 10 } },
                    { top: { r: 180, g: 70, b: 40 }, bottom: { r: 100, g: 40, b: 20 } },
                    { top: { r: 130, g: 40, b: 20 }, bottom: { r: 70, g: 20, b: 10 } },
                    { top: { r: 90, g: 30, b: 15 }, bottom: { r: 40, g: 10, b: 5 } }
                ],
                orbFrequency: {
                    heart: 1000,
                    shield: 1200,
                    coin: 250,
                    gravity: 200,
                    speed: 500,
                    tripleJump: 800
                },
                obstacleColors: {
                    spike: "black",
                    spikeTop: "black",
                    doubleSpike: "black",
                    doubleSpikeTop: "black",
                    block: "dimgray",
                    blockTop: "dimgray",
                    jumpPad: "gray",
                    jumpPadTop: "gray"
                }
            },
            {
                name: "Desierto de Fuego",
                obstacleFrequency: 70,
                obstacleTypes: [2, 3, 8, 9],
                orbTypes: ["coin", "gravity", "speed", "heart", "shield", "tripleJump"],
                hasRain: false,
                rainAmount: 0,
                gameSpeed: 10,
                requiredScore: 6500,
                backgroundColors: [
                    { top: { r: 255, g: 140, b: 0 }, bottom: { r: 150, g: 70, b: 0 } },
                    { top: { r: 255, g: 160, b: 30 }, bottom: { r: 170, g: 90, b: 20 } },
                    { top: { r: 220, g: 100, b: 10 }, bottom: { r: 130, g: 60, b: 10 } },
                    { top: { r: 180, g: 80, b: 0 }, bottom: { r: 100, g: 40, b: 0 } }
                ],
                orbFrequency: {
                    heart: 1000,
                    shield: 1200,
                    coin: 250,
                    gravity: 200,
                    speed: 500,
                    tripleJump: 800
                },
                obstacleColors: {
                    spike: "orange",
                    spikeTop: "orange",
                    block: "saddlebrown",
                    blockTop: "saddlebrown",
                    bigRock: "saddlebrown",
                    bigRockTop: "saddlebrown",
                    jumpPad: "goldenrod",
                    jumpPadTop: "goldenrod"
                }
            },
            {
                name: "Cielo Estrellado",
                obstacleFrequency: 50,
                obstacleTypes: [2, 3, 4, 5, 6, 7, 8, 9, 10],
                orbTypes: ["coin", "gravity", "speed", "heart", "shield", "tripleJump"],
                hasRain: false,
                rainAmount: 0,
                gameSpeed: 6,
                requiredScore: 8500,
                backgroundColors: [
                    { top: { r: 10, g: 10, b: 30 }, bottom: { r: 0, g: 0, b: 10 } },
                    { top: { r: 20, g: 20, b: 50 }, bottom: { r: 10, g: 10, b: 30 } },
                    { top: { r: 15, g: 15, b: 40 }, bottom: { r: 5, g: 5, b: 20 } },
                    { top: { r: 5, g: 5, b: 20 }, bottom: { r: 0, g: 0, b: 10 } }
                ],
                orbFrequency: {
                    heart: 1000,
                    shield: 1200,
                    coin: 250,
                    gravity: 200,
                    speed: 500,
                    tripleJump: 800
                },
                obstacleColors: {
                    spike: "white",
                    spikeTop: "white",
                    block: "midnightblue",
                    blockTop: "midnightblue",
                    bigRock: "midnightblue",
                    bigRockTop: "midnightblue",
                    jumpPad: "silver",
                    jumpPadTop: "silver",
                    floatingPlatform: "white"
                }
            },

            {
                name: "Ruinas de Hielo",
                obstacleFrequency: 65,
                obstacleTypes: [0, 1, 2, 3, 6, 7, 11, 12],
                orbTypes: ["coin", "gravity", "speed", "heart", "shield", "tripleJump"],
                hasRain: false,
                rainAmount: 0,
                gameSpeed: 9,
                requiredScore: 10500,
                backgroundColors: [
                    { top: { r: 180, g: 240, b: 255 }, bottom: { r: 120, g: 200, b: 230 } },
                    { top: { r: 150, g: 220, b: 255 }, bottom: { r: 100, g: 190, b: 220 } },
                    { top: { r: 130, g: 200, b: 240 }, bottom: { r: 80, g: 170, b: 210 } },
                    { top: { r: 100, g: 180, b: 220 }, bottom: { r: 60, g: 150, b: 190 } }
                ],
                orbFrequency: {
                    heart: 1000,
                    shield: 1200,
                    coin: 250,
                    gravity: 200,
                    speed: 500,
                    tripleJump: 800
                },
                obstacleColors: {
                    spike: "lightcyan",
                    spikeTop: "lightcyan",
                    doubleSpike: "lightcyan",
                    doubleSpikeTop: "lightcyan",
                    block: "powderblue",
                    blockTop: "powderblue",
                    bigRock: "powderblue",
                    bigRockTop: "powderblue",
                    jumpPad: "aliceblue",
                    jumpPadTop: "aliceblue"
                }
            },

            {
                name: "Abismo Carmes√≠",
                obstacleFrequency: 55,
                obstacleTypes: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
                orbTypes: ["coin", "gravity", "speed", "heart", "shield", "tripleJump"],
                hasRain: false,
                rainAmount: 0,
                gameSpeed: 11,
                requiredScore: 13000,
                backgroundColors: [
                    { top: { r: 120, g: 0, b: 0 }, bottom: { r: 60, g: 0, b: 0 } },
                    { top: { r: 150, g: 0, b: 0 }, bottom: { r: 90, g: 0, b: 0 } },
                    { top: { r: 180, g: 0, b: 0 }, bottom: { r: 120, g: 0, b: 0 } },
                    { top: { r: 100, g: 0, b: 0 }, bottom: { r: 50, g: 0, b: 0 } }
                ],
                orbFrequency: {
                    heart: 1000,
                    shield: 1200,
                    coin: 250,
                    gravity: 200,
                    speed: 500,
                    tripleJump: 800
                },
                obstacleColors: {
                    spike: "crimson",
                    spikeTop: "crimson",
                    doubleSpike: "crimson",
                    doubleSpikeTop: "crimson",
                    block: "darkred",
                    blockTop: "darkred",
                    bigRockTop: "darkred",
                    bigRock: "darkred",
                    jumpPad: "firebrick",
                    jumpPadTop: "firebrick",
                    floatingPlatform: "crimson"
                }
            }
        ];



        // Variables para mostrar el nombre del nivel
        let showLevelName = false;
        let levelNameOpacity = 0;
        let levelNameTimer = 0;
        const levelNameDisplayTime = 180; // frames que dura visible (por ejemplo 3 segundos a 60fps)
        const fadeSpeed = 0.02; // velocidad de aparici√≥n y desaparici√≥n

        function startLevelNameDisplay() {
            showLevelName = true;
            levelNameOpacity = 0;
            levelNameTimer = 0;
        }

        function updateLevelName() {
            if (!showLevelName) return;

            if (levelNameTimer < levelNameDisplayTime) {
                // Fade in
                if (levelNameOpacity < 1) {
                    levelNameOpacity += fadeSpeed;
                    if (levelNameOpacity > 1) levelNameOpacity = 1;
                }
            } else {
                // Fade out
                levelNameOpacity -= fadeSpeed;
                if (levelNameOpacity <= 0) {
                    levelNameOpacity = 0;
                    showLevelName = false;
                }
            }

            levelNameTimer++;
        }

        function drawLevelName() {
            if (!showLevelName) return;

            ctx.save();
            ctx.globalAlpha = levelNameOpacity;
            ctx.fillStyle = "#fff";
            ctx.font = "bold 33px Arial";
            ctx.textAlign = "center";
            ctx.shadowColor = "rgba(0,0,0,0.7)";
            ctx.shadowBlur = 8;
            ctx.fillText(niveles[nivelActual].name, canvas.width / 2, 60);
            ctx.restore();
        }


        let nivelActual = 0;
        let nivelTimer = niveles[nivelActual].duration;

        let transitionActive = false;
        let transitionProgress = 0;
        let prevBackgroundColors = niveles[0].backgroundColors;
        let nextBackgroundColors = niveles[0].backgroundColors;



        function checkLevelAdvance() {
            // Si hay un siguiente nivel
            if (nivelActual + 1 < niveles.length) {
                let nextLevel = niveles[nivelActual + 1];
                if (score >= nextLevel.requiredScore) {
                    startTransitionToLevel(nivelActual + 1);

                    console.log("Nivel: ", niveles[nivelActual].name);


                    startLevelNameDisplay();

                    // Reiniciar par√°metros seg√∫n el nuevo nivel
                    gameSpeed = niveles[nivelActual].gameSpeed;
                    if (niveles[nivelActual].hasRain) {
                        createRain(niveles[nivelActual].rainAmount || 15); // 15 por defecto para lluvias normales
                    } else {
                        rainDrops = [];
                    }

                    // Si quieres mostrar mensaje de transici√≥n en pantalla, podemos a√±adirlo aqu√≠.
                }
            }
        }




        function resetGame() {
            player.y = groundY - player.height;
            player.dy = 0;
            player.jumps = 0;
            inverted = false;
            tripleJumpActive = false;
            tripleJumpTimer = 0;

            obstacles = [];
            coins = [];
            orbs = [];
            speedOrbs = [];
            tripleJumpOrbs = [];
            heartOrbs = [];
            shieldOrbs = [];
            particles = [];
            floatingTexts = [];

            gameSpeed = 5;
            score = puntos;
            saltos = 0;
            monedas = 0;
            vidas = 1;

            frame = 0;
            gameOver = false;
            isEgg = true;
            nivelActual = 0;

            if (niveles[nivelActual].hasRain) {
                createRain();
            } else {
                rainDrops = [];
            }
            startLevelNameDisplay();
        }


        function startTransitionToLevel(levelIndex) {
            transitionActive = true;
            transitionProgress = 0;
            prevBackgroundColors = niveles[nivelActual].backgroundColors;
            nextBackgroundColors = niveles[levelIndex].backgroundColors;
            nivelActual = levelIndex;

            // Ajusta otros par√°metros seg√∫n el nuevo nivel
            gameSpeed = niveles[nivelActual].gameSpeed;
            if (niveles[nivelActual].hasRain) createRain();
            else rainDrops = [];
        }


        function lerpColor(a, b, t) {
            return {
                r: a.r + (b.r - a.r) * t,
                g: a.g + (b.g - a.g) * t,
                b: a.b + (b.b - a.b) * t,
            };
        }

        function getBlendedColors(t) {
            let blended = [];
            for (let i = 0; i < prevBackgroundColors.length; i++) {
                blended.push({
                    top: lerpColor(prevBackgroundColors[i].top, nextBackgroundColors[i].top, t),
                    bottom: lerpColor(prevBackgroundColors[i].bottom, nextBackgroundColors[i].bottom, t),
                });
            }
            return blended;
        }



        function update() {


            checkLevelAdvance();

            ctx.clearRect(0, 0, canvas.width, canvas.height);


            // Avanza lentamente el tiempo para el ciclo d√≠a-noche
            timeOfDay += 0.0001;
            if (timeOfDay > 1) timeOfDay = 0; // ciclo infinito

            function lerpColor(a, b, t) {
                const lerp = (v0, v1, t) => v0 + (v1 - v0) * t;
                return {
                    r: lerp(a.r, b.r, t),
                    g: lerp(a.g, b.g, t),
                    b: lerp(a.b, b.b, t)
                };
            }

            function rgbToString(c) {
                return `rgb(${Math.round(c.r)},${Math.round(c.g)},${Math.round(c.b)})`;
            }


            const nivelConfig = niveles[nivelActual];

            const colors = niveles[nivelActual].backgroundColors;



            if (transitionActive) {
                transitionProgress += 0.01; // Ajusta la velocidad de transici√≥n aqu√≠
                if (transitionProgress >= 1) {
                    transitionProgress = 1;
                    transitionActive = false;
                }
                const colorsToUse = getBlendedColors(transitionProgress);
                pintarFondoConColors(colorsToUse);
            } else {
                pintarFondoConColors(niveles[nivelActual].backgroundColors);
            }

            function pintarFondoConColors(colors) {
                const phase = timeOfDay * colors.length;
                const index = Math.floor(phase) % colors.length;
                const nextIndex = (index + 1) % colors.length;
                const t = phase - Math.floor(phase);

                const topColor = lerpColor(colors[index].top, colors[nextIndex].top, t);
                const bottomColor = lerpColor(colors[index].bottom, colors[nextIndex].bottom, t);

                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, `rgb(${Math.round(topColor.r)},${Math.round(topColor.g)},${Math.round(topColor.b)})`);
                gradient.addColorStop(1, `rgb(${Math.round(bottomColor.r)},${Math.round(bottomColor.g)},${Math.round(bottomColor.b)})`);

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }


            if (gameOver) {
                ctx.textAlign = "center";

                // Configura la sombra para todo el texto
                ctx.shadowColor = "rgba(0, 0, 0, 0.7)";  // sombra negra semitransparente
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                // Texto grande en rojo con sombra
                ctx.fillStyle = "yellow";
                ctx.font = canvas.height * 0.2 + "px sans-serif";
                ctx.fillText("Geometry Duck III", canvas.width / 2, canvas.height / 2 - canvas.height * 0.1);

                // Texto peque√±o en blanco con sombra
                ctx.fillStyle = "white";
                ctx.font = canvas.height * 0.04 + "px sans-serif";
                ctx.fillText("Puntaje m√°ximo: " + bestScore, canvas.width / 2, canvas.height / 2 + canvas.height * 0.10);
                ctx.fillText("Monedas m√°ximas: " + bestCoins, canvas.width / 2, canvas.height / 2 + canvas.height * 0.15);
                ctx.fillText("Maximo de Saltos: " + bestSaltos, canvas.width / 2, canvas.height / 2 + canvas.height * 0.20);

                ctx.fillStyle = "red";
                ctx.fillText("Pulsa para Iniciar", canvas.width / 2, canvas.height / 2 + canvas.height * 0.30);

                // Opcional: limpia sombra despu√©s si dibujas otros elementos sin sombra
                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                requestAnimationFrame(update);
                return;
            }


            if (tiendaAbierta) {
                // Pintar la tienda y no actualizar el juego mientras la tienda est√° abierta
                dibujarTienda();
                requestAnimationFrame(update);
                return;
            }

            if (paused) {
                // Mostrar texto de "Pausado" en el centro
                ctx.textAlign = "center";
                ctx.fillStyle = "yellow";
                ctx.font = canvas.height * 0.06 + "px sans-serif";
                ctx.fillText("PAUSA", canvas.width / 2, canvas.height / 2);

                requestAnimationFrame(update);
                return;
            }

            ctx.strokeStyle = "#888";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, ceilingY);
            ctx.lineTo(canvas.width, ceilingY);
            ctx.stroke();

            for (let i = 0; i < particles.length; i++) {
                let p = particles[i];
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 2, 2);



                p.x += p.dx;
                p.y += p.dy;
                p.life--;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                    i--;
                }
            }

            player.dy += inverted ? -gravity : gravity;
            player.y += player.dy;

            if (!inverted && player.y + player.height > groundY) {
                player.y = groundY - player.height;
                player.dy = 0;
                player.jumps = 0;
            } else if (inverted && player.y < ceilingY) {
                player.y = ceilingY;
                player.dy = 0;
                player.jumps = 0;
            }

            updateRain();



            if (invincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) {
                    invincible = false;
                }
            }


            ctx.save();

            ctx.shadowColor = invincible ? "red" : (tripleJumpActive ? "blue" : skins[skinActual].colorPato);
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            if (isEgg) {
                ctx.save();

                // Mover el contexto al centro del huevo
                ctx.translate(player.x + player.width / 2, player.y + player.height / 2);

                // Aplicar la rotaci√≥n
                ctx.rotate(eggRotation); // eggRotation es una variable global que vamos a actualizar

                // Dibujar el huevo centrado en 0,0 (porque ya traducimos)


                ctx.fillStyle = skins[skinActual].colorHuevo;
                ctx.beginPath();
                ctx.ellipse(0, 0, player.width / 2, player.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = "gray";
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            } else {
                ctx.save();

                if (inverted) {
                    ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
                    ctx.scale(1, -1);

                    ctx.drawImage(skins[skinActual].img, -player.width / 2, -player.height / 2, player.width, player.height);
                } else {
                    ctx.drawImage(skins[skinActual].img, player.x, player.y, player.width, player.height);
                }

                ctx.restore();
            }

            if (isEgg) {
                eggRotation += 0.1; // Ajusta velocidad de rotaci√≥n aqu√≠
            }


            if (nivelConfig.orbTypes.includes("heart") && frame % nivelConfig.orbFrequency.heart === 0) {
                let heartY = (canvas.height / 2) - 40;
                heartOrbs.push({ x: canvas.width + 1200, y: heartY, radius: 15 });
            }

            if (nivelConfig.orbTypes.includes("shield") && frame % nivelConfig.orbFrequency.shield === 0) {
                let shieldY = (canvas.height / 2) - 40;
                shieldOrbs.push({ x: canvas.width + 800, y: shieldY, radius: 15 });
            }

            if (nivelConfig.orbTypes.includes("coin") && frame % nivelConfig.orbFrequency.coin === 0) {
                let coinY;

                if (inverted) {
                    // Aparecen en la mitad superior
                    coinY = canvas.height * 0.05 + Math.random() * ((canvas.height / 2) - canvas.height * 0.1);
                } else {
                    // Aparecen en la mitad inferior
                    coinY = (canvas.height / 2) + Math.random() * (groundY - canvas.height / 2 - canvas.height * 0.1);
                }

                coins.push({ x: canvas.width + 600, y: coinY, radius: 15 });
            }

            if (nivelConfig.orbTypes.includes("gravity") && frame % nivelConfig.orbFrequency.gravity === 0) {
                let orbY = (canvas.height / 2) - 40;
                orbs.push({ x: canvas.width, y: orbY, radius: 10 });
            }

            if (nivelConfig.orbTypes.includes("speed") && frame % nivelConfig.orbFrequency.speed === 0) {
                let orbY = (canvas.height / 2) - 40;
                speedOrbs.push({ x: canvas.width + 200, y: orbY, radius: 20 });
            }

            if (nivelConfig.orbTypes.includes("tripleJump") && frame % nivelConfig.orbFrequency.tripleJump === 0) {
                let orbY = (canvas.height / 2) - 40;
                tripleJumpOrbs.push({ x: canvas.width + 400, y: orbY, radius: 10 });
            }







            if (frame % nivelConfig.obstacleFrequency === 0) {
                let cantidad = Math.floor(Math.random() * 7);
                for (let c = 0; c < cantidad; c++) {
                    let distancia = c * canvas.width * 0.075;

                    let typeIndex = nivelConfig.obstacleTypes[Math.floor(Math.random() * nivelConfig.obstacleTypes.length)];

                    let width = canvas.width * 0.025;
                    let height = canvas.height * 0.1;

                    if (typeIndex === 0) {
                        obstacles.push({ x: canvas.width + distancia, y: groundY - height, width, height, type: "spike" });
                    } else if (typeIndex === 1) {
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width, height, type: "spikeTop" });
                    } else if (typeIndex === 2 || typeIndex === 3) {
                        let blockHeight = typeIndex === 2 ? canvas.height * 0.05 : canvas.height * 0.15;
                        obstacles.push({ x: canvas.width + distancia, y: groundY - blockHeight, width: width * 1.5, height: blockHeight, type: "block" });
                    } else if (typeIndex === 4) {
                        obstacles.push({ x: canvas.width + distancia, y: groundY - canvas.height * 0.025, width: width * 2, height: canvas.height * 0.025, type: "jumpPad" });
                    } else if (typeIndex === 5) {
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width: width * 2, height: canvas.height * 0.025, type: "jumpPadTop" });
                    } else if (typeIndex === 6 || typeIndex === 7) {
                        let blockHeight = canvas.height * (0.05 + Math.random() * 0.05);
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width: width * 1.5, height: blockHeight, type: "blockTop" });
                    }
                    // ‚ú® Nuevo tipo: roca grande que bloquea casi todo el suelo
                    else if (typeIndex === 8) {
                        let bigHeight = canvas.height * 0.25;
                        obstacles.push({ x: canvas.width + distancia, y: groundY - bigHeight, width: width * 3, height: bigHeight, type: "bigRock" });
                    }
                    // ‚ú® Nuevo tipo: roca colgante grande en el techo
                    else if (typeIndex === 9) {
                        let bigHeight = canvas.height * 0.25;
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width: width * 3, height: bigHeight, type: "bigRockTop" });
                    }
                    // ‚ú® Nuevo tipo: plataforma flotante peque√±a (para futuros saltos dobles u orbes)
                    else if (typeIndex === 10) {
                        let platHeight = canvas.height * 0.025;
                        let platY = ceilingY + Math.random() * (groundY - ceilingY - platHeight);
                        obstacles.push({ x: canvas.width + distancia, y: platY, width: width * 2, height: platHeight, type: "floatingPlatform" });
                    }
                    // ‚ú® Nuevo tipo: pincho doble alto (obst√°culo peligroso)
                    else if (typeIndex === 11) {
                        let spikeHeight = canvas.height * 0.2;
                        obstacles.push({ x: canvas.width + distancia, y: groundY - spikeHeight, width, height: spikeHeight, type: "doubleSpike" });
                    } else if (typeIndex === 12) {
                        let spikeHeight = canvas.height * 0.2;
                        obstacles.push({ x: canvas.width + distancia, y: ceilingY, width, height: spikeHeight, type: "doubleSpikeTop" });
                    }

                }
            }


            ctx.fillStyle = "red";
            for (let i = 0; i < heartOrbs.length; i++) {
                let orb = heartOrbs[i];
                orb.x -= gameSpeed;

                ctx.save();
                ctx.translate(orb.x, orb.y);
                ctx.scale(orb.radius / 10, orb.radius / 10); // Ajusta tama√±o relativo (base: 10px de referencia)





                ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(-5, -5, -10, 2.5, 0, 10);
                ctx.bezierCurveTo(10, 2.5, 5, -5, 0, 0);
                ctx.closePath();
                ctx.fill();

                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;


                ctx.restore();







                // Colisi√≥n (la misma l√≥gica, usando bounding box del radio)
                if (player.x < orb.x + orb.radius &&
                    player.x + player.width > orb.x - orb.radius &&
                    player.y < orb.y + orb.radius &&
                    player.y + player.height > orb.y - orb.radius) {

                    vidas++;
                    heartOrbs.splice(i, 1);
                    i--;
                    score += 50;
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "red");
                    addFloatingText("+50", player.x + player.width / 2, player.y, "red");
                }
            }



            ctx.fillStyle = "yellow";
            for (let i = 0; i < shieldOrbs.length; i++) {
                let orb = shieldOrbs[i];
                orb.x -= gameSpeed;

                ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.beginPath();

                ctx.moveTo(orb.x, orb.y - orb.radius);
                ctx.lineTo(orb.x + orb.radius, orb.y);
                ctx.lineTo(orb.x, orb.y + orb.radius);
                ctx.lineTo(orb.x - orb.radius, orb.y);

                ctx.closePath();
                ctx.fill();

                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;



                if (player.x < orb.x + orb.radius &&
                    player.x + player.width > orb.x - orb.radius &&
                    player.y < orb.y + orb.radius &&
                    player.y + player.height > orb.y - orb.radius) {

                    invincible = true;
                    invincibleTimer = 600; // dura 10 segundos si el juego corre a 60 fps
                    shieldOrbs.splice(i, 1);
                    i--;
                    score += gameSpeed;
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "yellow");
                    addFloatingText("+" + Math.floor(gameSpeed), player.x + player.width / 2, player.y, "yellow");
                }
            }




            ctx.fillStyle = "gold";
            for (let i = 0; i < coins.length; i++) {
                let coin = coins[i];
                coin.x -= gameSpeed;



                ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.beginPath();



                ctx.arc(coin.x, coin.y, coin.radius, 0, Math.PI * 2);



                ctx.closePath();
                ctx.fill();

                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;



                if (
                    player.x < coin.x + coin.radius &&
                    player.x + player.width > coin.x - coin.radius &&
                    player.y < coin.y + coin.radius &&
                    player.y + player.height > coin.y - coin.radius
                ) {
                    monedas++;
                    dinero++;
                    localStorage.setItem("dinero", dinero);
                    coins.splice(i, 1);
                    i--;
                    score += 100;
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "gold");
                    addFloatingText("+100", player.x + player.width / 2, player.y, "gold");
                }
            }


            ctx.fillStyle = "blue";
            for (let i = 0; i < tripleJumpOrbs.length; i++) {
                let orb = tripleJumpOrbs[i];
                orb.x -= gameSpeed;

                let r = orb.radius;
                // Dibujar un tri√°ngulo equil√°tero apuntando hacia arriba para simbolizar salto extra





                ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.beginPath();


                ctx.moveTo(orb.x, orb.y - r);                // punta arriba
                ctx.lineTo(orb.x - r * Math.sin(Math.PI / 3), orb.y + r * 0.5); // abajo izquierda
                ctx.lineTo(orb.x + r * Math.sin(Math.PI / 3), orb.y + r * 0.5); // abajo derecha

                ctx.closePath();
                ctx.fill();

                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;




                // Colisi√≥n
                if (
                    player.x < orb.x + orb.radius &&
                    player.x + player.width > orb.x - orb.radius &&
                    player.y < orb.y + orb.radius &&
                    player.y + player.height > orb.y - orb.radius
                ) {
                    tripleJumpActive = true;
                    tripleJumpTimer = 800;
                    player.maxJumps = 3;
                    tripleJumpOrbs.splice(i, 1);
                    i--;
                    score += gameSpeed * 3;
                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "blue");
                    addFloatingText("+" + Math.floor(gameSpeed) * 3, player.x + player.width / 2, player.y, "blue");
                }
            }


            ctx.fillStyle = "cyan";
            for (let i = 0; i < orbs.length; i++) {
                let orb = orbs[i];
                orb.x -= gameSpeed;

                let r = orb.radius;
                // Dibujar un hex√°gono simple para simbolizar cambio de gravedad



                ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.beginPath();




                for (let j = 0; j < 6; j++) {
                    let angle = (Math.PI / 3) * j - Math.PI / 2; // iniciar punta arriba
                    let x = orb.x + r * Math.cos(angle);
                    let y = orb.y + r * Math.sin(angle);
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }



                ctx.closePath();
                ctx.fill();

                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;




                // Colisi√≥n
                if (
                    player.x < orb.x + orb.radius &&
                    player.x + player.width > orb.x - orb.radius &&
                    player.y < orb.y + orb.radius &&
                    player.y + player.height > orb.y - orb.radius
                ) {
                    inverted = !inverted;
                    orbs.splice(i, 1);
                    i--;
                    player.dy = 0;
                    player.jumps = 0;
                    score += 10;
                    createParticles(player.x + player.width, player.y + player.height, "cyan");
                    addFloatingText("+10", player.x + player.width / 2, player.y, "cyan");
                }
            }




            ctx.fillStyle = "white";
            for (let i = 0; i < speedOrbs.length; i++) {
                let orb = speedOrbs[i];
                orb.x -= gameSpeed;

                let r = orb.radius;

                ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.beginPath();
                ctx.moveTo(orb.x - r * 0.9, orb.y - r * 0.5);  // inicio arriba-izq (menos alto)
                ctx.lineTo(orb.x - r * 0.2, orb.y);            // parte media-izq (m√°s al centro)
                ctx.lineTo(orb.x - r * 0.5, orb.y);            // retroceso hacia la izquierda
                ctx.lineTo(orb.x + r * 0.9, orb.y + r * 0.6);  // extremo derecho abajo
                ctx.lineTo(orb.x + r * 0.2, orb.y);            // parte media-derecha
                ctx.lineTo(orb.x + r * 0.5, orb.y);            // avance a derecha
                ctx.closePath();
                ctx.fill();

                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;


                if (
                    player.x < orb.x + orb.radius &&
                    player.x + player.width > orb.x - orb.radius &&
                    player.y < orb.y + orb.radius &&
                    player.y + player.height > orb.y - orb.radius
                ) {
                    gameSpeed += 1;

                    speedOrbs.splice(i, 1);
                    i--;

                    score += 10 * gameSpeed;

                    createParticles(player.x + player.width / 2, player.y + player.height / 2, "white");
                    addFloatingText("+" + 10 * Math.floor(gameSpeed), player.x + player.width / 2, player.y, "white");
                }
            }










            for (let i = 0; i < obstacles.length; i++) {
                let obs = obstacles[i];
                obs.x -= gameSpeed;

                let nivelConfig = niveles[nivelActual];
                let color = nivelConfig.obstacleColors[obs.type] || "white";

                ctx.save(); // Guarda el estado antes de aplicar sombra y estilos

                // üåë Configura sombra y stroke para m√°xima visibilidad
                ctx.fillStyle = color;
                ctx.shadowColor = "black";
                ctx.shadowBlur = 2;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;

                ctx.strokeStyle = "black";
                ctx.lineWidth = 1;

                if (obs.type === "spike" || obs.type === "spikeTop") {
                    ctx.beginPath();
                    if (obs.type === "spike") {
                        ctx.moveTo(obs.x, obs.y + obs.height);
                        ctx.lineTo(obs.x + obs.width / 2, obs.y);
                        ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
                    } else {
                        ctx.moveTo(obs.x, obs.y);
                        ctx.lineTo(obs.x + obs.width / 2, obs.y + obs.height);
                        ctx.lineTo(obs.x + obs.width, obs.y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // ‚ú® Colisiones y efectos
                    if (player.x < obs.x + obs.width &&
                        player.x + player.width > obs.x &&
                        player.y < obs.y + obs.height &&
                        player.y + player.height > obs.y) {

                        if (invincible) {
                            createParticles(obs.x + obs.width / 2, obs.y + obs.height / 2, color);
                            obstacles.splice(i, 1);
                            i--;
                            score += 50;
                            addFloatingText("+50", player.x + player.width / 2, player.y, color);
                        } else {
                            if (vidas > 0) {
                                vidas--;
                                invincible = true;
                                invincibleTimer = 60;
                            } else {
                                gameOver = true;
                            }
                        }
                    }
                }

                else if (obs.type === "block" || obs.type === "blockTop") {
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);



                    if (player.x + player.width > obs.x && player.x < obs.x + obs.width) {
                        if (invincible &&
                            ((obs.type === "block" && !inverted) ||
                                (obs.type === "blockTop" && inverted)) &&
                            player.y + player.height > obs.y &&
                            player.y < obs.y + obs.height) {

                            createParticles(obs.x + obs.width / 2, obs.y + obs.height / 2, color);
                            obstacles.splice(i, 1);
                            i--;
                            score += 50;
                            addFloatingText("+50", player.x + player.width / 2, player.y, color);
                        } else {
                            if (obs.type === "block") {
                                if (!inverted) {
                                    if (player.y + player.height > obs.y && player.y + player.height <= obs.y + player.dy + gravity) {
                                        player.y = obs.y - player.height;
                                        player.dy = 0;
                                        player.jumps = 0;
                                    } else if (player.y + player.height > obs.y) {
                                        if (vidas > 0) {
                                            vidas--;
                                            invincible = true;
                                            invincibleTimer = 60;
                                        } else {
                                            gameOver = true;
                                        }
                                    }
                                } else {
                                    if (player.y < obs.y + obs.height && player.y >= obs.y + obs.height + player.dy - gravity) {
                                        player.y = obs.y + obs.height;
                                        player.dy = 0;
                                        player.jumps = 0;
                                    } else if (player.y < obs.y + obs.height && player.y + player.height > obs.y + obs.height) {
                                        if (vidas > 0) {
                                            vidas--;
                                            invincible = true;
                                            invincibleTimer = 60;
                                        } else {
                                            gameOver = true;
                                        }
                                    }
                                }
                            } else if (obs.type === "blockTop") {
                                if (!inverted) {
                                    if (player.y < obs.y + obs.height && player.y + player.height > obs.y) {
                                        player.y = obs.y + obs.height;
                                        player.dy = 0;
                                        player.jumps = 0;
                                    }
                                } else {
                                    if (player.y <= obs.y + obs.height && player.y >= obs.y + obs.height + player.dy - gravity) {
                                        player.y = obs.y + obs.height;
                                        player.dy = 0;
                                        player.jumps = 0;
                                    } else if (player.y < obs.y + obs.height) {
                                        if (vidas > 0) {
                                            vidas--;
                                            invincible = true;
                                            invincibleTimer = 60;
                                        } else {
                                            gameOver = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }


                else if (obs.type === "bigRock" || obs.type === "bigRockTop") {
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

                    if (player.x + player.width > obs.x && player.x < obs.x + obs.width) {
                        if (invincible &&
                            ((obs.type === "bigRock" && !inverted) ||
                                (obs.type === "bigRockTop" && inverted)) &&
                            player.y + player.height > obs.y &&
                            player.y < obs.y + obs.height) {

                            createParticles(obs.x + obs.width / 2, obs.y + obs.height / 2, color);
                            obstacles.splice(i, 1);
                            i--;
                            score += 50;
                            addFloatingText("+50", player.x + player.width / 2, player.y, color);

                        } else {
                            if (obs.type === "bigRock") {
                                if (!inverted) {
                                    if (player.y + player.height > obs.y && player.y + player.height <= obs.y + player.dy + gravity) {
                                        player.y = obs.y - player.height;
                                        player.dy = 0;
                                        player.jumps = 0;
                                    } else if (player.y + player.height > obs.y) {
                                        if (vidas > 0) {
                                            vidas--;
                                            invincible = true;
                                            invincibleTimer = 60;
                                        } else {
                                            gameOver = true;
                                        }
                                    }
                                }
                            } else if (obs.type === "bigRockTop") {
                                if (inverted) {
                                    if (player.y < obs.y + obs.height && player.y >= obs.y + obs.height + player.dy - gravity) {
                                        player.y = obs.y + obs.height;
                                        player.dy = 0;
                                        player.jumps = 0;
                                    } else if (player.y < obs.y + obs.height) {
                                        if (vidas > 0) {
                                            vidas--;
                                            invincible = true;
                                            invincibleTimer = 60;
                                        } else {
                                            gameOver = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }



                else if (obs.type === "jumpPad" || obs.type === "jumpPadTop") {
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

                    let padStrength = canvas.height * 0.045;

                    if (obs.type === "jumpPad") {
                        if (player.x + player.width > obs.x &&
                            player.x < obs.x + obs.width &&
                            player.y + player.height > obs.y &&
                            player.y + player.height < obs.y + obs.height + 10) {
                            player.dy = -padStrength;
                            player.jumps = 2;
                        }
                    } else {
                        if (player.x + player.width > obs.x &&
                            player.x < obs.x + obs.width &&
                            player.y < obs.y + obs.height &&
                            player.y + player.height > obs.y) {
                            player.dy = inverted ? padStrength : -padStrength;
                            player.jumps = 2;
                        }
                    }
                }



                // ‚ú® Nuevo: floatingPlatform (plataforma flotante)
                else if (obs.type === "floatingPlatform") {
                    //ctx.fillStyle = "#7FDBFF"; // Un color distinto para distinguirla
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

                    if (player.x + player.width > obs.x && player.x < obs.x + obs.width) {
                        if (!inverted) {
                            // Gravedad normal: el jugador se apoya desde arriba
                            if (player.y + player.height > obs.y && player.y + player.height <= obs.y + player.dy + gravity) {
                                player.y = obs.y - player.height;
                                player.dy = 0;
                                player.jumps = 0;
                            }
                        } else {
                            // Gravedad invertida: el jugador se apoya desde abajo
                            if (player.y < obs.y + obs.height && player.y >= obs.y + obs.height + player.dy - gravity) {
                                player.y = obs.y + obs.height;
                                player.dy = 0;
                                player.jumps = 0;
                            }
                        }
                    }
                }

                // ‚ú® Nuevo: doubleSpike (pincho alto √∫nico)
                else if (obs.type === "doubleSpike" || obs.type === "doubleSpikeTop") {
                    ctx.beginPath();


                    if (obs.type === "doubleSpike") {

                        ctx.moveTo(obs.x, obs.y + obs.height); // base izquierda
                        ctx.lineTo(obs.x + obs.width / 2, obs.y); // punta arriba
                        ctx.lineTo(obs.x + obs.width, obs.y + obs.height); // base derecha
                    } else {
                        ctx.moveTo(obs.x, obs.y);
                        ctx.lineTo(obs.x + obs.width / 2, obs.y + obs.height);
                        ctx.lineTo(obs.x + obs.width, obs.y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();


                    // Colisi√≥n igual que con spikes normales pero m√°s alto
                    if (player.x < obs.x + obs.width &&
                        player.x + player.width > obs.x &&
                        player.y < obs.y + obs.height &&
                        player.y + player.height > obs.y) {

                        if (invincible) {
                            createParticles(obs.x + obs.width / 2, obs.y + obs.height / 2, color);
                            obstacles.splice(i, 1);
                            i--;
                            score += 50;
                            addFloatingText("+50", player.x + player.width / 2, player.y, color);
                        } else {
                            if (vidas > 0) {
                                vidas--;
                                invincible = true;
                                invincibleTimer = 60;
                            } else {
                                gameOver = true;
                            }
                        }
                    }
                }




                ctx.restore(); // Restaura para que otros elementos no hereden sombra y stroke

                if (obs.x + obs.width < 0) {
                    obstacles.splice(i, 1);
                    i--;
                    score += gameSpeed;
                }
            }


            ctx.textAlign = "left";
            ctx.fillStyle = "white";
            ctx.font = canvas.height * 0.05 + "px sans-serif";
            ctx.fillText("Puntaje: " + Math.floor(score) + " Saltos: " + saltos + " Monedas: " + monedas + " Vidas: " + vidas + " Monedas Totales: " + dinero, 20, groundY + canvas.height * 0.05);

            if (invincible) {
                let alpha = getBlinkAlpha(invincibleTimer);
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha.toFixed(2)})`; // gold con alpha variable
                ctx.font = canvas.height * 0.035 + "px sans-serif";
                ctx.textAlign = "right";
                ctx.fillText("Invencible: " + (invincibleTimer / 60).toFixed(1) + "s", canvas.width - 20, 30);
            }

            if (tripleJumpActive) {
                let alpha = getBlinkAlpha(tripleJumpTimer);
                ctx.fillStyle = `rgba(0, 191, 255, ${alpha.toFixed(2)})`; // deepskyblue con alpha variable
                ctx.font = canvas.height * 0.035 + "px sans-serif";
                ctx.textAlign = "right";
                ctx.fillText("Triple Salto: " + (tripleJumpTimer / 60).toFixed(1) + "s", canvas.width - 20, 60);
            }



            frame++;
            updateFloatingTexts();
            requestAnimationFrame(update);
            score += 0.042;
            gameSpeed += 0.00042;
            // Guarda el mejor puntaje
            if (score > bestScore) {
                bestScore = Math.floor(score);
                localStorage.setItem("bestScore", bestScore);
            }

            // Guarda la mejor cantidad de monedas tambi√©n
            if (monedas > bestCoins) {
                bestCoins = monedas;
                localStorage.setItem("bestCoins", bestCoins);
            }

            if (saltos > bestSaltos) {
                bestSaltos = saltos;
                localStorage.setItem("bestSaltos", bestSaltos);
            }




            nivelTimer--;
            if (nivelTimer <= 0) {
                nivelActual = (nivelActual + 1) % niveles.length;
                nivelTimer = niveles[nivelActual].duration;

                // actualizar gameSpeed y otras propiedades
                gameSpeed = niveles[nivelActual].gameSpeed;
            }

            updateLevelName();


            drawLevelName();


        }

        update();
        createRain();








    </script>

</body>

</html>